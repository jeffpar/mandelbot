{"version":3,"sources":[" [synthetic:util/polyfill] "," [synthetic:util/defineproperty] "," [synthetic:util/global] "," [synthetic:es6/math/trunc] ","src/mandelbot.js"],"names":["$jscomp.defineProperty","$jscomp.global","idTimeout","activeMandelbots","iNextMandelbot","msTimeslice","nMaxIterationsPerTimeslice","nMaxBigIterationsPerTimeslice","constructor","Mandelbot","widthGrid","heightGrid","xCenter","yCenter","dxCenter","dyCenter","bigNumbers","palette","shape","idView","idStatus","Mandelbot.DEFAULT.XCENTER","Mandelbot.DEFAULT.YCENTER","getURLHash","getURLValue","Mandelbot.KEY.BIGNUMBERS","Mandelbot.KEY.PALETTE","aResults","aPrevious","addControl","initView","widthView","heightView","canvasView","document","getElementById","contextView","width","height","getContext","initSelect","updateStatus","canvasGrid","createElement","Mandelbot.DEFAULT.WGRID","Mandelbot.DEFAULT.HGRID","contextGrid","imageGrid","createImageData","Mandelbot.DEFAULT.DXCENTER","Mandelbot.DEFAULT.DYCENTER","xReset","Mandelbot.KEY.XCENTER","xDefault","yReset","Mandelbot.KEY.YCENTER","yDefault","dxReset","Mandelbot.KEY.DXCENTER","dxDefault","dyReset","Mandelbot.KEY.DYCENTER","dyDefault","prepGrid","err","message","name","id","mandelbot","control","controlStatus","onclick","control.onclick","updatePrevious","controlPrevious","hash","pop","x","y","dx","dy","url","toDataURL","link","download","href","body","appendChild","click","removeChild","window","alert","open","controlSelect","colStart","rowStart","msStart","colSelect","rowSelect","widthSelect","heightSelect","fSelectDefault","addEventListener","onTouchStart","event","processSelectAction","Mandelbot.ACTION.PRESS","onTouchMove","Mandelbot.ACTION.MOVE","onTouchEnd","Mandelbot.ACTION.RELEASE","onMouseDown","button","onMouseMove","onMouseUp","action","colView","rowView","targetTouches","length","pageX","pageY","colOffset","rowOffset","isNaN","offsetLeft","offsetTop","offsetParent","offsetWidth","offsetHeight","colGrid","Math","round","rowGrid","preventDefault","hideSelection","fZeroAlpha","n","i","data","putImageData","Date","now","rowDelta","abs","colDelta","aspectSelect","aspectGrid","colBeg","rowBeg","colEnd","rowEnd","xInc","times","dividedBy","yInc","xLeft","plus","yTop","minus","showSelection","lineWidth","strokeStyle","strokeRect","drawImage","fUpdate","BigNumber","console","log","updateRow","row","col","setGridPoint","colorBgnd","nMin","min","nMaxIterations","floor","sqrt","updateHash","push","location","Mandelbot.KEY.ID","updateMandelbots","rowUpdate","r","trunc","colUpdate","widthUpdate","xUpdate","yUpdate","hashTable","match","reKeyPair","exec","key","init","undefined","value","removeAttribute","sDisabled","setAttribute","messageStatus","innerHTML","rgb","alpha","calibrate","nIterationsStart","nCalibrations","nIterationsAvg","nLoops","nIterationsTotal","msTotal","nIterationsInc","Mandelbot.isMandelbrot","isMandelbrot","nMax","nMaxIterationsPerNumber","aa","bb","a","b","m","l","as","bs","lt","toNumber","getRGBFromHSV","h","v","hp","c","s","g","WGRID","HGRID","XCENTER","YCENTER","DXCENTER","DYCENTER","PRESS","MOVE","RELEASE","Mandelbot.LOG_BASE","Mandelbot.LOG_HALFBASE","ID","BIGNUMBERS","PALETTE","Mandelbot.calibrate","fInit","nMandelbots","fUpdated","colDirty","rowDirty","widthDirty","heightDirty","nMaxIterationsTotal","fSwap","Mandelbot.getRGBFromHSV","setTimeout","prototype","newMandelbot","fAutoUpdate"],"mappings":"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","file":"mandelbot.min.js","sourcesContent":[null,null,null,null,"/**\n * @fileoverview Implements Mandelbots\n * @author <a href=\"mailto:Jeff@pcjs.org\">Jeff Parsons</a>\n * @copyright Copyright © 2017 [Jeff Parsons](mailto:Jeff@pcjs.org)\n *\n * This file is part of an open-source project (https://github.com/jeffpar/mandelbot) with no formal license.\n * All portions not licensed from other sources may be freely reused.  Any derivative work just needs to provide\n * attribution along with the above copyright.\n *\n * Portions copyright 2012 Christian Stigen Larsen and licensed under [Apache License](http://www.apache.org/licenses/LICENSE-2.0),\n * Version 2.0.  Those portions are clearly identified in [mandelbot.js](https://github.com/jeffpar/mandelbot/blob/master/src/mandelbot.js)\n * and must be accompanied by the same Apache License if they are redistributed.\n */\n\n\"use strict\";\n\n// import * as BigNumber from \"./bignumber/bignumber\";\n\n/**\n * DEBUG\n *\n * Set to false by the Closure Compiler to disable debug-only code, assertions, etc.\n *\n * @define {boolean}\n */\nvar DEBUG = true;\n\nlet idTimeout = 0;\nlet activeMandelbots = [];\nlet iNextMandelbot = 0;\nlet msTimeslice = (1000 / 60)|0;\nlet nMaxIterationsPerNumber = 100;      // default maximum iterations per number\nlet nMaxIterationsPerTimeslice;         // updated by a one-time call to calibrate() using normal numbers\nlet nMaxBigIterationsPerTimeslice;      // updated by a one-time call to calibrate() using BigNumbers instead\n\n/**\n * TODO: Bring the Mandelbot class property definitions up-to-date.\n *\n * The class must be marked \"unrestricted\" because the Closure Compiler's default (\"struct\") requires\n * that all class properties be defined in the body of the constructor, which is too restrictive.  I'd\n * prefer a compilation mode somewhere between \"struct\" and \"unrestricted\" that requires all properties\n * to be defined either by the constructor or any methods it calls, because that would help catch any\n * lazily defined properties that may not not be initialized in time.  But that's not an option.\n *\n * @class Mandelbot\n * @unrestricted\n * @property {string|undefined} idView\n * @property {Object} hashTable\n * @property {boolean} bigNumbers\n * @property {number} widthView\n * @property {number} heightView\n * @property {number} widthGrid\n * @property {number} heightGrid\n * @property {number|BigNumber} xCenter\n * @property {number|BigNumber} yCenter\n * @property {number|BigNumber} dxCenter\n * @property {number|BigNumber} dyCenter\n * @property {number} palette\n * @property {number} shape\n * @property {number} colorBgnd\n * @property {Array.<number>} aResults\n * @property {Array.<string>} aPrevious\n * @property {HTMLCanvasElement} canvasView\n * @property {CanvasRenderingContext2D} contextView\n * @property {HTMLCanvasElement} canvasGrid\n * @property {CanvasRenderingContext2D} contextGrid\n * @property {ImageData} imageGrid\n * @property {Element|undefined} controlSelect\n * @property {Element|null} controlStatus\n * @property {string} messageStatus\n * @property {Element|null} controlPrevious\n * @property {number} nMaxIterations\n * @property {number} colUpdate\n * @property {number} rowUpdate\n * @property {number} widthUpdate\n * @property {number|BigNumber} xLeft\n * @property {number|BigNumber} xInc\n * @property {number|BigNumber} yTop\n * @property {number|BigNumber} xInc\n * @property {number|BigNumber} xUpdate\n * @property {number|BigNumber} yUpdate\n */\nclass Mandelbot {\n    /**\n     * Mandelbot(widthGrid, heightGrid, xCenter, yCenter, dxCenter, dyCenter, bigNumbers, palette, shape, idView, idStatus)\n     *\n     * The constructor records information about the View canvas (eg, its dimensions, 2D context, etc), and then\n     * creates the internal Grid canvas using the supplied dimensions, which usually match the View canvas dimensions\n     * unless a different aspect ratio or scaling effect is desired.  See initView() and initGrid().\n     *\n     * The Grid canvas represents the Cartesian coordinate grid onto which all the complex numbers are plotted,\n     * after they have passed through the Mandelbrot set calculations.  The Grid canvas is then drawn onto the View\n     * canvas.  The use of two canvases also enables double-buffering, which helps eliminate animation flicker.\n     * Take, for example, the selection rectangle: as the rectangle changes shape, it must be erased and redrawn,\n     * but since both those operations are performed on the Grid canvas first, before View canvas is updated, there's\n     * no risk of flicker.\n     *\n     * Any of the coordinate parameters (x,y,dx,dy) can be specified as numbers OR strings, since strings may be needed\n     * to represent BigNumbers that can't be expressed as a 64-bit floating-point numbers.  If bigNumbers is true, then\n     * those parameters are passed through to the BigNumber constructor as-is; otherwise, those parameters are coerced\n     * to numbers using the unary \"plus\" operator.\n     *\n     * @this {Mandelbot}\n     * @param {number} [widthGrid] (grid canvas width; default is view canvas width or 200)\n     * @param {number} [heightGrid] (grid canvas height; default is view canvas height or 200)\n     * @param {number|string} [xCenter] (the x coordinate of the center of the image; default is -0.65)\n     * @param {number|string} [yCenter] (the y coordinate of the center of the image; default is 0)\n     * @param {number|string} [dxCenter] (the distance from xCenter to the sides of the image; default is 1.5)\n     * @param {number|string} [dyCenter] (the distance from yCenter to the top/bottom of the image; default is 1.5)\n     * @param {boolean} [bigNumbers] (true to use BigNumbers for floating-point calculations; default is false)\n     * @param {number} [palette] (one of the Mandelbot.PALETTE values; default is GRAY)\n     * @param {number} [shape] (one of the Mandelbot.SHAPE values; default is RECT)\n     * @param {string} [idView] (the id of an existing view canvas, if any)\n     * @param {string} [idStatus] (the id of an existing status control, if any)\n     */\n    constructor(widthGrid = 0, heightGrid = 0,\n                xCenter = Mandelbot.DEFAULT.XCENTER,\n                yCenter = Mandelbot.DEFAULT.YCENTER,\n                dxCenter, dyCenter, bigNumbers, palette, shape, idView, idStatus)\n    {\n        if (DEBUG) this.logDebug = [];\n        this.getURLHash(idView);\n        this.bigNumbers = !!this.getURLValue(Mandelbot.KEY.BIGNUMBERS, bigNumbers || false);\n        this.palette = /** @type {number} */ (this.getURLValue(Mandelbot.KEY.PALETTE, palette || Mandelbot['PALETTE']['GRAY']));\n        this.shape = shape || Mandelbot['SHAPE']['RECT'];\n        /*\n         * TODO: Allow the caller to specify the background color; useful if the page contains a non-rectangular\n         * view or non-default color.\n         */\n        this.colorBgnd = 0xffffff;\n        this.aResults = [0, 0, 0, 0];\n        this.aPrevious = [];\n        try {\n            /*\n             * Why the try/catch?  Bad things CAN happen here; for example, bogus dimensions can cause\n             * the createImageData() call in initGrid() to barf.  So rather than trying to imagine every\n             * possible failure here, let's just catch and display any errors.\n             */\n            this.addControl(Mandelbot['CONTROL_STATUS'], idStatus);\n            if (this.initView(idView) && this.initGrid(widthGrid || this.widthView, heightGrid || this.heightView)) {\n                dxCenter = dxCenter || Mandelbot.DEFAULT.DXCENTER;\n                dyCenter = dyCenter || (Mandelbot.DEFAULT.DYCENTER * (this.heightGrid / this.widthGrid));\n                this.xReset  = this.getURLValue(Mandelbot.KEY.XCENTER, this.xDefault = xCenter, false);\n                this.yReset  = this.getURLValue(Mandelbot.KEY.YCENTER, this.yDefault = yCenter, false);\n                this.dxReset = this.getURLValue(Mandelbot.KEY.DXCENTER, this.dxDefault = dxCenter, true);\n                this.dyReset = this.getURLValue(Mandelbot.KEY.DYCENTER, this.dyDefault = dyCenter, true);\n                this.prepGrid(this.xReset, this.yReset, this.dxReset, this.dyReset, false);\n            }\n        } catch(err) {\n            this.updateStatus(err.message);\n        }\n    }\n\n    /**\n     * addControl(name, id)\n     *\n     * @this {Mandelbot}\n     * @param {string} name\n     * @param {string} [id] (if empty, this is method is a no-op)\n     */\n    addControl(name, id)\n    {\n        let mandelbot = this;\n        let control = id? document.getElementById(id) : null;\n\n        switch (name) {\n\n        case Mandelbot['CONTROL_STATUS']:\n            this.controlStatus = control;\n            this.updateStatus();\n            break;\n\n        case Mandelbot['CONTROL_RESET']:\n            /*\n             * The RESET control, if any, doesn't need to be recorded, because this one-time initialization is all\n             * that's required.\n             */\n            if (control) {\n                control.onclick = function onReset() {\n                    /*\n                     * If RESET is clicked after all coordinates have already returned to the page's reset values,\n                     * then revert to the built-in defaults (think of it as a hard reset, as opposed to a soft reset).\n                     */\n                    mandelbot.aPrevious = [];\n                    mandelbot.updatePrevious();\n                    if (mandelbot.xCenter == mandelbot.xReset && mandelbot.yCenter == mandelbot.yReset) {\n                        if (mandelbot.dxCenter == mandelbot.dxReset && mandelbot.dyCenter == mandelbot.dyReset) {\n                            mandelbot.prepGrid(Mandelbot.DEFAULT.XCENTER,  Mandelbot.DEFAULT.YCENTER,\n                                               Mandelbot.DEFAULT.DXCENTER, Mandelbot.DEFAULT.DYCENTER * (mandelbot.heightGrid / mandelbot.widthGrid));\n                            return;\n                        }\n                    }\n                    mandelbot.prepGrid(mandelbot.xReset, mandelbot.yReset, mandelbot.dxReset, mandelbot.dyReset);\n                };\n            }\n            break;\n\n        case Mandelbot['CONTROL_PREVIOUS']:\n            this.controlPrevious = control;\n            if (control) {\n                control.onclick = function onPrevious() {\n                    let hash = mandelbot.aPrevious.pop();\n                    if (hash != null) {\n                        mandelbot.getURLHash(mandelbot.idView, hash);\n                        mandelbot.bigNumbers = !!mandelbot.getURLValue(Mandelbot.KEY.BIGNUMBERS, mandelbot.bigNumbers);\n                        mandelbot.palette = /** @type {number} */ (mandelbot.getURLValue(Mandelbot.KEY.PALETTE, mandelbot.palette));\n                        let x  = mandelbot.getURLValue(Mandelbot.KEY.XCENTER,  mandelbot.xDefault, false);\n                        let y  = mandelbot.getURLValue(Mandelbot.KEY.YCENTER,  mandelbot.yDefault, false);\n                        let dx = mandelbot.getURLValue(Mandelbot.KEY.DXCENTER, mandelbot.dxDefault, true);\n                        let dy = mandelbot.getURLValue(Mandelbot.KEY.DYCENTER, mandelbot.dyDefault, true);\n                        mandelbot.prepGrid(x, y, dx, dy);\n                        mandelbot.updatePrevious();\n                    }\n                }\n            }\n            this.updatePrevious();\n            break;\n\n        case Mandelbot['CONTROL_DOWNLOAD']:\n            if (control) {\n                control.onclick = function onDownload() {\n                    let name = \"mandelbot.png\";\n                    let url = mandelbot.canvasView.toDataURL(\"image/png\");\n                    let link = document.createElement('a');\n                    if (link && typeof link.download != 'string') link = null;\n                    if (link) {\n                        link.href = url;\n                        link.download = name;\n                        document.body.appendChild(link);    // Firefox allegedly requires the link to be in the body\n                        link.click();\n                        document.body.removeChild(link);\n                        window.alert('Check your Downloads folder for ' + name + '.');\n                    }\n                    else {\n                        window.open(url);\n                        window.alert('Check your browser for a new window/tab containing the requested data' + (name? (' (' + name + ')') : ''));\n                    }\n                }\n            }\n            break;\n\n        case Mandelbot['CONTROL_DEBUG']:\n            if (DEBUG && control) {\n                this.controlDebug = control;\n                control.onclick = function onDebug() {\n                    mandelbot.updateStatus();\n                };\n            }\n            break;\n        }\n    }\n\n    /**\n     * initView(idView)\n     *\n     * If no view is provided, then this is simply treated as a \"headless\" Mandelbot.\n     *\n     * @this {Mandelbot}\n     * @param {string|undefined} idView\n     * @return {boolean}\n     */\n    initView(idView)\n    {\n        this.idView = idView;\n        this.widthView = this.heightView = 0;\n        if (idView) {\n            this.canvasView = /** @type {HTMLCanvasElement} */ (document.getElementById(idView));\n            if (this.canvasView) {\n                this.widthView = this.canvasView.width;\n                this.heightView = this.canvasView.height;\n                this.contextView = this.canvasView.getContext(\"2d\");\n                if (this.contextView) {\n                    /*\n                     * TODO: Verify that this property really only has much (if any) effect when the View context\n                     * has HIGHER resolution than the Grid context, and that it only makes sense on the View context;\n                     * also, I'm not sure how many browsers really support it, and which browsers require special\n                     * prefixes on the property (eg, 'mozImageSmoothingEnabled', 'webkitImageSmoothingEnabled', etc).\n                     * Finally, if it's possible that some users really WANT to produce low-res \"fuzzy\" images, then\n                     * consider adding a parameter to control this setting.\n                     *\n                     * Refer to: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/imageSmoothingEnabled\n                     */\n                    this.contextView['imageSmoothingEnabled'] = false;\n                    this.initSelect(this.canvasView);\n                    return true;\n                }\n            }\n            this.updateStatus(\"Missing view canvas\");\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * initGrid(widthGrid, heightGrid)\n     *\n     * If no width and/or height is specified, and no view width or height is available, we use defaults.\n     *\n     * @this {Mandelbot}\n     * @param {number} widthGrid\n     * @param {number} heightGrid\n     * @return {boolean}\n     */\n    initGrid(widthGrid, heightGrid)\n    {\n        this.canvasGrid = /** @type {HTMLCanvasElement} */ (document.createElement(\"canvas\"));\n        if (this.canvasGrid) {\n            this.canvasGrid.width = this.widthGrid = widthGrid || Mandelbot.DEFAULT.WGRID;\n            this.canvasGrid.height = this.heightGrid = heightGrid || Mandelbot.DEFAULT.HGRID;\n            if (this.contextGrid = this.canvasGrid.getContext(\"2d\")) {\n                this.imageGrid = this.contextGrid.createImageData(this.widthGrid, this.heightGrid);\n                if (this.imageGrid) {\n                    return true;\n                }\n            }\n        }\n        this.updateStatus(\"Unable to create grid canvas\");\n        return false;\n    }\n\n    /**\n     * initSelect(control)\n     *\n     * @this {Mandelbot}\n     * @param {HTMLCanvasElement} control\n     */\n    initSelect(control)\n    {\n        if (!this.controlSelect) {\n\n            let mandelbot = this;\n\n            this.controlSelect = control;\n\n            /*\n             * colStart and rowStart record the last 'touchstart' or 'mousedown' position on the grid;\n             * they will be propagated to colSelect and rowSelect if/when movement is detected, and they\n             * will be reset to -1 when movement has ended (eg, 'touchend' or 'mouseup').\n             */\n            this.colStart = this.rowStart = -1;\n            this.msStart = 0;\n\n            /*\n             * A selection exists IFF colSelect and rowSelect are positive; widthSelect and heightSelect\n             * CAN be negative, if the rectangle is extended above and/or to the left of the starting point,\n             * instead of down and to the right, so be careful.\n             */\n            this.colSelect = this.rowSelect = -1;\n            this.widthSelect = this.heightSelect = 0;\n\n            /*\n             * As long as fSelectDefault is false, processSelectAction() will call preventDefault()\n             * on every event, to prevent the page from moving/scrolling while we process select events.\n             */\n            this.fSelectDefault = false;\n\n            /*\n             * NOTE: The mouse event handlers below deal only with events where the left button is involved\n             * (ie, left button is pressed, down, or released).\n             */\n            control.addEventListener(\n                'touchstart',\n                function onTouchStart(event) {\n                    mandelbot.processSelectAction(Mandelbot.ACTION.PRESS, event);\n                }\n            );\n            control.addEventListener(\n                'touchmove',\n                function onTouchMove(event) {\n                    mandelbot.processSelectAction(Mandelbot.ACTION.MOVE, event);\n                }\n            );\n            control.addEventListener(\n                'touchend',\n                function onTouchEnd(event) {\n                    mandelbot.processSelectAction(Mandelbot.ACTION.RELEASE, event);\n                }\n            );\n            control.addEventListener(\n                'mousedown',\n                function onMouseDown(event) {\n                    if (!event.button) {\n                        mandelbot.processSelectAction(Mandelbot.ACTION.PRESS, event);\n                    }\n                }\n            );\n            control.addEventListener(\n                'mousemove',\n                function onMouseMove(event) {\n                    /*\n                     * Sadly, the 'buttons' property is not supported in all browsers (eg, Safari),\n                     * so my original test for the left button (event.buttons & 0x1) is not sufficient.\n                     * Instead, we'll rely on our own colStart/rowStart properties, which should only\n                     * be positive after 'mousedown' and before 'mouseup'.\n                     */\n                    if (mandelbot.colStart >= 0) {\n                        mandelbot.processSelectAction(Mandelbot.ACTION.MOVE, event);\n                    }\n                }\n            );\n            control.addEventListener(\n                'mouseup',\n                function onMouseUp(event) {\n                    if (!event.button) {\n                        mandelbot.processSelectAction(Mandelbot.ACTION.RELEASE, event);\n                    }\n                }\n            );\n            control.addEventListener(\n                'mouseout',\n                function onMouseUp(event) {\n                    if (mandelbot.colStart >= 0) {\n                        mandelbot.processSelectAction(Mandelbot.ACTION.RELEASE, event);\n                    }\n                }\n            );\n        }\n    }\n\n    /**\n     * processSelectAction(action, event)\n     *\n     * Although this may appear to be an event handler, I prefer to think of it as an \"action handler\";\n     * it deals with specific user actions that are usually accompanied by an Event object, but the exact\n     * nature of the Event object, if any, will vary according to browser and device.\n     *\n     * @this {Mandelbot}\n     * @param {number} action\n     * @param {Event} [event] (eg, the object from a 'touch' or 'mouse' event)\n     */\n    processSelectAction(action, event)\n    {\n        let colView, rowView, colGrid, rowGrid;\n\n        if (action < Mandelbot.ACTION.RELEASE) {\n            /**\n             * @name Event\n             * @property {Array} targetTouches\n             */\n            event = event || window.event;\n\n            if (!event.targetTouches || !event.targetTouches.length) {\n                colView = event.pageX;\n                rowView = event.pageY;\n            } else {\n                colView = event.targetTouches[0].pageX;\n                rowView = event.targetTouches[0].pageY;\n            }\n\n            /*\n             * Touch coordinates (that is, the pageX and pageY properties) are relative to the page, so to make\n             * them relative to the canvas, we must subtract the canvas's left and top positions.  This Apple web page:\n             *\n             *      https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/AddingMouseandTouchControlstoCanvas/AddingMouseandTouchControlstoCanvas.html\n             *\n             * makes it sound simple, but it turns out we have to walk the canvas' entire \"parentage\" of DOM elements\n             * to get the exact offsets.\n             */\n            let colOffset = 0;\n            let rowOffset = 0;\n            let control = this.controlSelect;\n            do {\n                if (!isNaN(control.offsetLeft)) {\n                    colOffset += control.offsetLeft;\n                    rowOffset += control.offsetTop;\n                }\n            } while ((control = control.offsetParent));\n\n            /*\n             * Due to the responsive nature of our pages, the displayed size of the canvas may be smaller than the\n             * allocated size, and the coordinates we receive from events are based on the currently displayed size.\n             */\n            colView = (colView - colOffset) * (this.widthView / this.controlSelect.offsetWidth);\n            rowView = (rowView - rowOffset) * (this.heightView / this.controlSelect.offsetHeight);\n\n            /*\n             * Next, we need to convert colView,rowView to colGrid,rowGrid, because the selection rectangle is drawn\n             * on the grid canvas, not the view canvas (to avoid unwanted erase/flicker issues as the rectangle changes).\n             */\n            colGrid = Math.round((this.widthGrid * colView) / this.widthView);\n            rowGrid = Math.round((this.heightGrid * rowView) / this.heightView);\n        }\n\n        if (!this.fSelectDefault) event.preventDefault();\n\n        this.hideSelection();\n\n        if (action == Mandelbot.ACTION.PRESS) {\n            /*\n             * All we do is record the grid position of that event, transitioning colStart and rowStart\n             * from negative to non-negative values (grid positions cannot be negative).\n             */\n            this.colStart = colGrid;\n            this.rowStart = rowGrid;\n            this.msStart = Date.now();\n            if (DEBUG) this.logDebug.push(\"press action x,y=\" + this.colStart + \",\" + this.rowStart);\n        }\n        else if (action == Mandelbot.ACTION.MOVE) {\n            /*\n             * In the case of a mouse, this can happen all the time, whether a button is 'down' or not, but\n             * our event listener automatically suppresses all moves except those where the left button is down.\n             *\n             * Also, we don't want to change the selection unless the delta is at least some minimal amount\n             * (eg, 10 points), because otherwise we could mis-detect a sloppy click/tap as some tiny selection.\n             */\n            let colDelta = Math.abs(this.colStart - colGrid), rowDelta = Math.abs(this.rowStart - rowGrid);\n            if (colDelta >= 10 && rowDelta >= 10) {\n                this.colSelect = this.colStart;\n                this.rowSelect = this.rowStart;\n                this.widthSelect = colGrid - this.colSelect;\n                this.heightSelect = rowGrid - this.rowSelect;\n                /*\n                 * Constrain the selection rectangle to one whose aspect ratio matches that of the grid;\n                 * if needed, we arbitrarily modify the width (not the height) to bring it into compliance.\n                 */\n                let aspectGrid = Math.abs(this.widthGrid / this.heightGrid);\n                let aspectSelect = Math.abs(this.widthSelect / this.heightSelect);\n                if (aspectSelect != aspectGrid) {\n                    let widthSelect = Math.abs((this.widthGrid * this.heightSelect) / this.heightGrid);\n                    this.widthSelect = (this.widthSelect < 0)? -widthSelect : widthSelect;\n                }\n                if (DEBUG) this.logDebug.push(\"move action dx,dy=\" + this.widthSelect + \",\" + this.heightSelect);\n            }\n        }\n        else if (action == Mandelbot.ACTION.RELEASE) {\n            /*\n             * Here's the overall RELEASE logic:\n             *\n             *      if this is a click/tap (msRelease < 200ms)\n             *          if there is a selection rectangle\n             *              if the click/tap is INSIDE the rectangle\n             *                  calculate new position and range\n             *              else\n             *                  cancel the selection\n             *          else\n             *              calculate new position only\n             *      else\n             *          do nothing (most likely, the user just finished making a new selection)\n             *\n             * All 'mouseup' events include a position, and on iOS touch devices, the 'touchend' event includes\n             * a position as well.  Sadly, on Android touch devices, the 'touchend' event does NOT include a position,\n             * so the colGrid and rowGrid variables we calculate above cannot be relied upon here.\n             *\n             * However, since our main concern here is what to do on click/tap action, we should be able to rely on\n             * colStart and rowStart (we assumed that the apple did not fall far from the tree).\n             */\n            let msRelease = Date.now() - this.msStart;\n            if (msRelease < 200) {\n\n                if (DEBUG) this.logDebug.push(\"click action x,y=\" + this.colStart + \",\" + this.rowStart + \" dx,dy=\" + this.widthSelect + \",\" + this.heightSelect);\n\n                let xCenter, yCenter, dxCenter, dyCenter;\n\n                if (this.widthSelect && this.heightSelect) {\n                    /*\n                     * Since there's a selection rectangle, let's see if this RELEASE occurred inside or\n                     * outside the rectangle.\n                     */\n                    let colBeg = this.colSelect;\n                    let rowBeg = this.rowSelect;\n                    let colEnd = this.colSelect + this.widthSelect;\n                    let rowEnd = this.rowSelect + this.heightSelect;\n                    /*\n                     * Since the width and/or height can be negative (if the selection extended above or to\n                     * the left of the starting position), swap the beginning and ending positions as needed\n                     * to simplify the range check below.\n                     */\n                    if (colEnd < colBeg) {\n                        colBeg = colEnd;\n                        colEnd = this.colSelect;\n                    }\n                    if (rowEnd < rowBeg) {\n                        rowBeg = rowEnd;\n                        rowEnd = this.rowSelect;\n                    }\n                    if (this.colStart > colBeg && this.colStart < colEnd && this.rowStart > rowBeg && this.rowStart <= rowEnd) {\n                        /*\n                         * The action occurred inside the selection, so calculate a new range.\n                         */\n                        if (DEBUG) this.logDebug.push(\"click inside \" + colBeg + \",\" + rowBeg + \"--\" + colEnd + \",\" + rowEnd);\n\n                        if (!this.bigNumbers) {\n                            dxCenter = ((colEnd - colBeg) * this.xInc) / 2;\n                            dyCenter = ((rowEnd - rowBeg) * this.yInc) / 2;\n                            xCenter = this.xLeft + (colBeg * this.xInc) + dxCenter;\n                            yCenter = this.yTop  - (rowBeg * this.yInc) - dyCenter;\n                        } else {\n                            dxCenter = this.xInc.times(colEnd - colBeg).dividedBy(2);\n                            dyCenter = this.yInc.times(rowEnd - rowBeg).dividedBy(2);\n                            xCenter = this.xLeft.plus(this.xInc.times(colBeg)).plus(dxCenter);\n                            yCenter = this.yTop.minus(this.yInc.times(rowBeg)).minus(dyCenter);\n                        }\n                        this.prepGrid(xCenter, yCenter, dxCenter, dyCenter, true);\n                    }\n                    else {\n                        if (DEBUG) this.logDebug.push(\"click outside \" + colBeg + \",\" + rowBeg + \"--\" + colEnd + \",\" + rowEnd);\n                    }\n                }\n                else {\n                    /*\n                     * Since there's NO selection rectangle, treat this as a re-positioning operation.\n                     */\n                    if (!this.bigNumbers) {\n                        xCenter = this.xLeft + (this.colStart * this.xInc);\n                        yCenter = this.yTop  - (this.rowStart * this.yInc);\n                    } else {\n                        xCenter = this.xLeft.plus(this.xInc.times(this.colStart));\n                        yCenter = this.yTop.minus(this.yInc.times(this.rowStart));\n                    }\n                    this.prepGrid(xCenter, yCenter, this.dxCenter, this.dyCenter, true);\n                }\n                this.colSelect = this.rowSelect = -1;\n                this.widthSelect = this.heightSelect = 0;\n            }\n            else {\n                /*\n                 * Here, we assume the RELEASE simply signals the end of a selection operation; nothing to do (yet).\n                 */\n                if (DEBUG) this.logDebug.push(\"release action x,y=\" + this.colSelect + \",\" + this.rowSelect + \" dx,dy=\" + this.widthSelect + \",\" + this.heightSelect);\n            }\n            this.colStart = this.rowStart = -1;\n            this.msStart = 0;\n        }\n        else {\n            if (DEBUG) this.logDebug.push(\"unrecognized action: \" + action);\n        }\n\n        this.showSelection();\n    }\n\n    /**\n     * hideSelection()\n     *\n     * This removes any selection rectangle from the grid by simply redrawing all image data onto the grid,\n     * after first ensuring that none of the grid positions contain transparent values (ie, zero alpha).\n     *\n     * There are many optimizations we could perform here to reduce the amount grid canvas we are touching.\n     * For example, we could re-enable those commented-out putImageData() parameters; however, it's not quite\n     * that simple, because the strokeRect() performed by showSelection() actually touches more pixels than that.\n     *\n     * @this {Mandelbot}\n     */\n    hideSelection()\n    {\n        if (this.colSelect >= 0) {\n            if (this.fZeroAlpha) {\n                let n = this.widthGrid * this.heightGrid * 4;\n                for (let i = 0; i < n; i += 4) this.imageGrid.data[i + 3] = 0xff;\n                this.fZeroAlpha = false;\n            }\n            this.contextGrid.putImageData(this.imageGrid, 0, 0 /*, this.colSelect, this.rowSelect, this.widthSelect, this.heightSelect */);\n        }\n    }\n\n    /**\n     * showSelection()\n     *\n     * This draws the selection rectangle, if any, onto the grid, and then refreshes the view from the grid.\n     *\n     * @this {Mandelbot}\n     */\n    showSelection()\n    {\n        if (this.colSelect >= 0) {\n            this.contextGrid.lineWidth = 1;\n            this.contextGrid.strokeStyle = \"#00FF00\";\n            this.contextGrid.strokeRect(this.colSelect, this.rowSelect, this.widthSelect, this.heightSelect);\n        }\n        /*\n         * We want to refresh the view regardless, in case hideSelection() removed a previously visible selection.\n         */\n        if (this.contextView) {\n            this.contextView.drawImage(this.canvasGrid, 0, 0, this.widthGrid, this.heightGrid, 0, 0, this.widthView, this.heightView);\n        }\n    }\n\n    /**\n     * prepGrid(xCenter, yCenter, dxCenter, dyCenter, fUpdate)\n     *\n     * Resets colUpdate and rowUpdate (the next position on the grid to be updated) and calculates xUpdate and\n     * yUpdate (the x and y coordinates corresponding to that grid position).\n     *\n     * We also calculate several values that are constant for the next updateGrid() operation: xLeft and yTop are\n     * the left-most and top-most x,y values, and xInc and yInc are the appropriate x,y increments.\n     *\n     * fUpdate defaults to true; it must be explicitly set to false to prevent the updateHash() and updateMandelbots()\n     * calls, which only the constructor does, and it must be explicitly set to true for updateHash() to also update\n     * the stack of hashes in the aPrevious array; otherwise, it's assumed that the caller just popped (or reset) the\n     * array, so we don't want updateHash() interfering.\n     *\n     * @this {Mandelbot}\n     * @param {number|BigNumber} xCenter\n     * @param {number|BigNumber} yCenter\n     * @param {number|BigNumber} dxCenter\n     * @param {number|BigNumber} dyCenter\n     * @param {boolean} [fUpdate]\n     */\n    prepGrid(xCenter, yCenter, dxCenter, dyCenter, fUpdate)\n    {\n        if (!this.bigNumbers) {\n            this.xCenter = xCenter;\n            this.yCenter = yCenter;\n            this.dxCenter = dxCenter;\n            this.dyCenter = dyCenter;\n            /*\n             * I ran into a very strange Chrome-only bug, where if I immediately used any of the four\n             * preceding properties, the following calculations would *sometimes* result in NaN values.\n             * Setting breakpoints in the code, adding more logging, etc, would eliminate the bug.\n             *\n             *      this.xLeft = this.xCenter - this.dxCenter;\n             *      this.xInc = (this.dxCenter * 2) / this.widthGrid;\n             *      this.yTop = this.yCenter + this.dyCenter;\n             *      this.yInc = (this.dyCenter * 2) / this.heightGrid;\n             *\n             * It's probably a symptom of the fact that those are new properties being added to the object,\n             * which may force V8 to change its assumptions about the shape of the object at an inopportune\n             * time.  However, this function IS called from the constructor, so I consider it part of the\n             * object's initialization sequence.  Having separate initializers for those properties in the\n             * constructor, only to have them reinitialized by this function, seems silly.\n             */\n            this.xLeft = xCenter - dxCenter;\n            this.xInc = (dxCenter * 2) / this.widthGrid;\n            this.yTop = yCenter + dyCenter;\n            this.yInc = (dyCenter * 2) / this.heightGrid;\n            console.log(\"prepGrid(\" + this.idView + \"): \" + this.xCenter + \"-\" + this.dxCenter + \" \" + this.widthGrid + \" (\" + this.xLeft + \"+\" + this.xInc + \")\");\n        }\n        else {\n            /*\n             * Normally, if bigNumbers is true, the inputs will already be BigNumbers, but there is at least\n             * one exception: when onReset() calls us with hard-coded numbers.  Since the BigNumber constructor\n             * accepts both numbers and BigNumbers, the simplest solution is to always call the constructor.\n             */\n            this.xCenter = new BigNumber(xCenter);\n            this.yCenter = new BigNumber(yCenter);\n            this.dxCenter = new BigNumber(dxCenter);\n            this.dyCenter = new BigNumber(dyCenter);\n            this.xLeft = this.xCenter.minus(this.dxCenter);\n            this.xInc = this.dxCenter.times(2).dividedBy(this.widthGrid).round(20);\n            this.yTop = this.yCenter.plus(this.dyCenter);\n            this.yInc = this.dyCenter.times(2).dividedBy(this.heightGrid).round(20);\n        }\n        this.updateRow(0);\n        /*\n         * It's best to (re)initialize the entire grid with the background color, so that if we need to erase\n         * a selection rectangle from a portion of the grid that hasn't been calculated yet -- either because\n         * shape is non-zero (ie, not a rectangle) or because the calculation process hasn't reached the bottom\n         * of the grid yet -- that erasure can easily be done by blasting the entire grid image onto the grid\n         * canvas; see hideSelection() for details.\n         *\n         * One wrinkle you'll notice here is that we're calling setGridPoint() with the alpha parameter set to\n         * zero, which means all uncalculated points are initially transparent.  We do this so that, as long\n         * as you don't make any selections, all grid positions outside the calculation area remain transparent,\n         * allowing you to save the final image with transparency intact.  However, the first time you make a\n         * selection, hideSelection() will write non-zero (0xff) alpha values into all grid positions, ensuring\n         * that any selection rectangle will be properly erased.\n         */\n        this.fZeroAlpha = true;\n        for (let row = 0; row < this.heightGrid; row++) {\n            for (let col = 0; col < this.widthGrid; col++) {\n                this.setGridPoint(col, row, this.colorBgnd, 0);\n            }\n        }\n        this.nMaxIterations = Mandelbot.getMaxIterations(this.dxCenter, this.dyCenter);\n        this.updateStatus(\"X: \" + this.xCenter + \", Y: \" + this.yCenter + \", D: +/-\" + this.dxCenter + \", Max Iterations: \" + this.nMaxIterations + (this.bigNumbers? \" (BigNumbers)\" : \"\"));\n        if (fUpdate !== false) {\n            this.updateHash(fUpdate);\n            updateMandelbots(true);\n        }\n    }\n\n    /**\n     * updateRow(row)\n     *\n     * In a rectangular world, this merely needs to set colUpdate to zero and widthUpdate to widthGrid.\n     *\n     * In a circular world, we must calculate the starting colUpdate appropriate for the current row and\n     * then update widthUpdate to match.  Imagine we have a grid that's 30x30, so the corresponding grid radius\n     * is 15 units.  For each row, we must determine the point on the grid where the grid radius intersects\n     * the current grid row, and begin calculating at that point.\n     *\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . * * * * * * * * * * * . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . C . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n     *\n     * On the above grid, the coordinates of C are (0,0), so if we're working on the second row from the top,\n     * it has the equation y = 14, and the equation representing the circular boundary intersecting that row is\n     * x^2 + y^2 = 15^2.  The value for x is therefore sqrt(15^2 - y^2), or sqrt(225 - 196), or +/-5.39, which\n     * we round to +/-5.\n     *\n     * @this {Mandelbot}\n     * @param {number} row\n     */\n    updateRow(row)\n    {\n        this.rowUpdate = row;\n        if (!this.shape) {\n            this.colUpdate = 0;\n            this.widthUpdate = this.widthGrid;\n        } else {\n            let r = Math.trunc(this.heightGrid / 2);\n            let y = r - this.rowUpdate;\n            let x = Math.round(Math.sqrt((r * r) - (y * y)));\n            this.colUpdate = Math.trunc(this.widthGrid / 2) - x;\n            this.widthUpdate = x * 2;\n        }\n        if (!this.bigNumbers) {\n            this.xUpdate = this.xLeft + this.xInc * this.colUpdate;\n            if (!row) {\n                this.yUpdate = this.yTop;\n            } else {\n                this.yUpdate -= this.yInc;\n            }\n        } else {\n            this.xUpdate = this.xLeft.plus(this.xInc.times(this.colUpdate));\n            if (!row) {\n                this.yUpdate = this.yTop.plus(0);\n            } else {\n                this.yUpdate = this.yUpdate.minus(this.yInc);\n            }\n        }\n    }\n\n    /**\n     * updateGrid()\n     *\n     * Continues updating the Mandelbot's grid where we left off, until either the entire grid has been updated OR\n     * we have exhausted the maximum number of iterations allowed for the current timeslice.\n     *\n     * @this {Mandelbot}\n     * @return {boolean} (true if grid was updated, false if no change)\n     */\n    updateGrid()\n    {\n        let fUpdated = false;\n        let colDirty = this.colUpdate;\n        let rowDirty = this.rowUpdate;\n        let widthDirty = 0, heightDirty = 0;\n        let nMaxIterationsTotal = Math.floor((this.bigNumbers? nMaxBigIterationsPerTimeslice : nMaxIterationsPerTimeslice) / activeMandelbots.length);\n        while (this.rowUpdate < this.heightGrid) {\n            while (nMaxIterationsTotal > 0 && this.widthUpdate-- > 0) {\n                let m = this.nMaxIterations;\n                let n = Mandelbot.isMandelbrot(this.xUpdate, this.yUpdate, m, this.aResults);\n                this.setGridPoint(this.colUpdate++, this.rowUpdate, Mandelbot.getColor(this.palette, this.aResults));\n                if (!this.bigNumbers) {\n                    this.xUpdate += this.xInc;\n                } else {\n                    this.xUpdate = this.xUpdate.plus(this.xInc);\n                }\n                if (!heightDirty) widthDirty++;\n                nMaxIterationsTotal -= (m - n);\n                fUpdated = true;\n            }\n            if (nMaxIterationsTotal <= 0) break;\n            this.updateRow(this.rowUpdate + 1);\n            heightDirty++;\n            colDirty = 0;\n            widthDirty = this.widthGrid;\n        }\n        if (fUpdated) {\n            if (this.colUpdate > 0) heightDirty++;\n            this.drawGrid(colDirty, rowDirty, widthDirty, heightDirty);\n        }\n        return fUpdated;\n    }\n\n    /**\n     * getURLHash(idView, hash)\n     *\n     * If the hash portion of the URL contains values for idView, store those values in hashTable;\n     * if this is a \"headless\" Mandelbot (idView is not set), then its hash table will be empty.\n     *\n     * TODO: We don't currently support encoding values for multiple Mandelbots in a single URL; all\n     * we do is verify that the current URL hash is for the current Mandelbot.  Only the Mandelbot\n     * that last updated the URL via updateHash() will be successful.\n     *\n     * @this {Mandelbot}\n     * @param {string|undefined} idView\n     * @param {string} [hash] (default is location.hash)\n     */\n    getURLHash(idView, hash = location.hash)\n    {\n        this.hashTable = {};\n        if (idView) {\n            let hashTable = {};\n            let match, reKeyPair = /([^#&=]+)=([^&]*)/g;\n            while (match = reKeyPair.exec(hash)) {\n                hashTable[match[1]] = match[2];\n            }\n            if (hashTable[Mandelbot.KEY.ID] == idView) {\n                this.hashTable = hashTable;\n            }\n        }\n    }\n\n    /**\n     * getURLValue(key, init, abs)\n     *\n     * If the specified value has an override in hashTable, use it; otherwise, use the given initial value.\n     *\n     * If init is a boolean, then the hash is evaluated as a boolean, but the return value is always a number (0 or 1);\n     * we don't want to the muddy the waters by making boolean another possible return type, so callers will generally\n     * apply \"!!\" to the result to produce a real boolean.\n     *\n     * If abs is defined (true or false), then the return value is either a number or a BigNumber, as appropriate;\n     * if abs is NOT defined, the return value is ALWAYS a number.  For example, abs is omitted from keys like PALETTE,\n     * which is always a number (never a BigNumber).\n     *\n     * Unfortunately, the Closure Compiler isn't smart enough to realize that whenever abs is omitted, the return\n     * type is always number, so those callers will want to coerce (cast) the return value to number.\n     *\n     * @this {Mandelbot}\n     * @param {string} key\n     * @param {number|string|boolean} init\n     * @param {boolean} [abs] (true to return absolute value)\n     * @return {number|BigNumber}\n     */\n    getURLValue(key, init, abs)\n    {\n        let hash = this.hashTable[key];\n        if (typeof init == 'boolean') {\n            return (hash && (hash == 'true' || +hash) || !hash && init)? 1 : 0;\n        }\n        let value;\n        init = hash || init;\n        if (this.bigNumbers && abs !== undefined) {\n            value = new BigNumber(init);\n            if (abs) value = value.abs();\n        } else {\n            /*\n             * Since the initial values are allowed to be numbers OR strings, and since BigNumber support was\n             * not requested, we coerce those parameters to numbers using the unary \"plus\" operator; if they are\n             * are already numeric values, the operator has no effect, and if any value was negative, don't worry,\n             * it will remain negative.\n             */\n            value = +init;\n            if (abs) value = Math.abs(value);\n        }\n        return value;\n    }\n\n    /**\n     * updateHash(fPush)\n     *\n     * If this Mandelbot has an idView, update the hash portion of the URL with new values.\n     *\n     * @this {Mandelbot}\n     * @param {boolean} [fPush]\n     */\n    updateHash(fPush)\n    {\n        if (this.idView) {\n            if (fPush) {\n                this.aPrevious.push(location.hash);\n                this.updatePrevious();\n            }\n            let hash = Mandelbot.KEY.ID + '=' + this.idView;\n            hash += '&' + Mandelbot.KEY.XCENTER  + '=' + this.xCenter;\n            hash += '&' + Mandelbot.KEY.YCENTER  + '=' + this.yCenter;\n            hash += '&' + Mandelbot.KEY.DXCENTER + '=' + this.dxCenter;\n            hash += '&' + Mandelbot.KEY.DYCENTER + '=' + this.dyCenter;\n            /*\n             * I used to encode BIGNUMBERS only if it was true (since the default is false), but\n             * then it becomes difficult to override the setting on pages that set bigNumbers to true,\n             * so now we always encode.\n             */\n            hash += '&' + Mandelbot.KEY.BIGNUMBERS + '=' + this.bigNumbers;\n            hash += '&' + Mandelbot.KEY.PALETTE + '=' + this.palette;\n            location.hash = hash;\n        }\n    }\n\n    /**\n     * updatePrevious()\n     *\n     * The CONTROL_PREVIOUS control, if any, only needs its 'disabled' attribute updated.\n     *\n     * @this {Mandelbot}\n     */\n    updatePrevious()\n    {\n        let sDisabled = 'disabled';\n        if (this.controlPrevious) {\n            if (this.aPrevious.length) {\n                this.controlPrevious.removeAttribute(sDisabled);\n            } else {\n                this.controlPrevious.setAttribute(sDisabled, sDisabled);\n            }\n        }\n    }\n\n    /**\n     * updateStatus(message)\n     *\n     * @this {Mandelbot}\n     * @param {string} [message]\n     */\n    updateStatus(message)\n    {\n        message = message || this.messageStatus || \"\";\n        if (DEBUG) {\n            if (message) console.log(message);\n            for (let i = 0; i < this.logDebug.length; i++) {\n                console.log(this.logDebug[i]);\n                if (this.controlDebug) {\n                    if (message) message += \"<br/>\";\n                    message += this.logDebug[i];\n                }\n            }\n            this.logDebug = [];\n        }\n        if (!this.controlStatus) {\n            this.messageStatus = message;\n        } else {\n            this.controlStatus.innerHTML = message;\n            this.messageStatus = \"\";\n        }\n    }\n\n    /**\n     * drawGrid(colDirty, rowDirty, widthDirty, heightDirty)\n     *\n     * @this {Mandelbot}\n     * @param {number} [colDirty]\n     * @param {number} [rowDirty]\n     * @param {number} [widthDirty]\n     * @param {number} [heightDirty]\n     */\n    drawGrid(colDirty = 0, rowDirty = 0, widthDirty = this.widthGrid, heightDirty = this.heightGrid)\n    {\n        this.contextGrid.putImageData(this.imageGrid, 0, 0, colDirty, rowDirty, widthDirty, heightDirty);\n        if (this.contextView) {\n            this.contextView.drawImage(this.canvasGrid, 0, 0, this.widthGrid, this.heightGrid, 0, 0, this.widthView, this.heightView);\n        }\n    }\n\n    /**\n     * setGridPoint(col, row, rgb, alpha)\n     *\n     * @this {Mandelbot}\n     * @param {number} col\n     * @param {number} row\n     * @param {number} rgb\n     * @param {number} [alpha]\n     */\n    setGridPoint(col, row, rgb, alpha = 0xff)\n    {\n        let i = (col + row * this.widthGrid) * 4;\n        this.imageGrid.data[i] = rgb & 0xff;\n        this.imageGrid.data[i+1] = (rgb >> 8) & 0xff;\n        this.imageGrid.data[i+2] = (rgb >> 16) & 0xff;\n        this.imageGrid.data[i+3] = alpha;\n    }\n\n    /**\n     * calibrate(nIterationsStart, nCalibrations, bigNumbers)\n     *\n     * Estimate how many isMandelbrot() iterations can be performed in TIMESLICE milliseconds.\n     * The process starts by performing the half the default (maximum) number of iterations for\n     * a single Mandelbrot number.  Then it doubles the number of iterations until TIMESLICE\n     * is equaled or exceeded.\n     *\n     * @param {number} [nIterationsStart]\n     * @param {number} [nCalibrations]\n     * @param {boolean} [bigNumbers]\n     * @return {number} (of operations to perform before yielding)\n     */\n    static calibrate(nIterationsStart = 0, nCalibrations = 1, bigNumbers = false)\n    {\n        let nIterationsAvg = 0, nLoops = 0;\n        do {\n            let nIterationsTotal = 0;\n            let msStart = Date.now(), msTotal;\n            let nIterationsInc = (nMaxIterationsPerNumber / 2)|0;\n            do {\n                nIterationsInc *= 2;\n                let x = bigNumbers? new BigNumber(Mandelbot.DEFAULT.XCENTER) : Mandelbot.DEFAULT.XCENTER;\n                let y = bigNumbers? new BigNumber(Mandelbot.DEFAULT.YCENTER) : Mandelbot.DEFAULT.YCENTER;\n                let n = Mandelbot.isMandelbrot(x, y, nIterationsStart + nIterationsInc);\n                msTotal = Date.now() - msStart;\n                if (msTotal >= msTimeslice) break;\n                nIterationsTotal += (nIterationsStart + nIterationsInc) - n;\n                nIterationsStart = 0;\n            } while (true);\n            nIterationsAvg += nIterationsTotal;\n            if (nCalibrations) nIterationsStart = Math.floor(nIterationsTotal / nCalibrations);\n            nLoops++;\n        } while (--nCalibrations > 0);\n        return Math.floor(nIterationsAvg / nLoops);\n    }\n\n    /**\n     * isMandelbrot(x, y, nMax, aResults)\n     *\n     * This is where the magic happens.  As https://en.wikipedia.org/wiki/Mandelbrot_set explains:\n     *\n     *      The Mandelbrot set is the set of complex numbers c for which the function f(z) = z^2 + c does not\n     *      diverge when iterated from z = 0.\n     *\n     *      Mandelbrot set images may be created by sampling the complex numbers and determining, for each sample\n     *      point c, whether the result of iterating the above function goes to infinity.  Treating the real and\n     *      imaginary parts of c as image coordinates (x + yi) on the complex plane, [points] may then be colored\n     *      according to how rapidly the sequence z^2 + c diverges, with the color 0 (black) usually used for points\n     *      where the sequence does not diverge.\n     *\n     * @param {number|BigNumber} x\n     * @param {number|BigNumber} y\n     * @param {number} [nMax] (iterations)\n     * @param {Array.<number>} [aResults] (optional array to return additional data)\n     * @return {number} (of iterations remaining, 0 if presumed to be in the Mandelbrot set)\n     */\n    static isMandelbrot(x, y, nMax, aResults)\n    {\n        nMax = nMax || nMaxIterationsPerNumber;\n        let n = nMax;\n        /*\n         * Let's use z{n} to indicate the nth iteration of z in the Mandelbrot function:\n         *\n         *      z{n+1} = z{n}^2 + c\n         *\n         * z is a complex number of the form (a + bi), where a and b are real and imaginary coefficients;\n         * the initial z, z{0}, is (0 + 0i).\n         *\n         * c is also a complex number of the form (x + yi), and it remains constant; the x and y coefficients\n         * are inputs to this function.\n         *\n         * The n+1 iteration requires calculating the square of the nth iteration, which means squaring (a + bi):\n         *\n         *      (a + bi) * (a + bi)\n         *\n         * which expands to:\n         *\n         *      (a * a) + (2 * a * b * i) + (b * i * b * i)\n         *\n         * which can be simplified (since i * i = -1):\n         *\n         *      (a * a) + (2 * a * b * i) - (b * b)\n         *\n         * So the real and imaginary coefficients for z{n+1}, after adding the coefficients of c (x and y), are:\n         *\n         *      a{n+1} = (a * a) - (b * b) + x\n         *      b{n+1} = (2 * a * b) + y\n         *\n         * We also need to know the magnitude of this result, because if the magnitude equals or exceeds 2, then\n         * the number is not part of the Mandelbrot set (ie, it has \"escaped\").\n         *\n         * The magnitude, m, comes from calculating the hypotenuse of the right triangle whose sides are a and b,\n         * using the Pythagorean theorem:\n         *\n         *      m = Math.sqrt(a^2 + b^2)\n         *\n         * To avoid the sqrt() operation, we can simply calculate m = (a * a) + (b * b) and compare that to (2 * 2)\n         * or 4 instead; happily, we've already calculated (a * a) and (b * b), so calculating m is just an additional,\n         * um, addition.\n         *\n         * TODO: I need to find something conclusive regarding whether the \"escape\" criteria is >= 2 or > 2.  The code\n         * assumes the former, in part because this is what the original Scientific American article from August 1985\n         * said:\n         *\n         *      A straightforward result in the theory of complex-number iterations guarantees that the iterations\n         *      will drive z to infinity if and only if at some stage z reaches a size of 2 or greater.\n         *\n         * so I'm sticking with that (although, admittedly, the article is not 100% consistent on this point).\n         */\n        let aa = 0, bb = 0;\n        if (typeof x == \"number\") {\n            let a = 0, b = 0, m;\n            do {\n                b = 2 * a * b + y;\n                a = aa - bb + x;\n                m = (aa = a * a) + (bb = b * b);\n            } while (--n > 0 && m < 4);\n            if (n && aResults) {\n                let l = 4;  // iterate a few (4) more times to provide more detail; see http://linas.org/art-gallery/escape/escape.html\n                do {\n                    b = 2 * a * b + y;\n                    a = aa - bb + x;\n                    aa = a * a; bb = b * b;\n                } while (--l > 0);\n            }\n        } else {\n            /*\n             * The BigNumber loop.  Note that as and bs (\"a squared\" and \"b squared\") are BigNumber\n             * values that are converted to normal numbers aa and bb at the end, because at this time,\n             * we don't support returning BigNumber values in the results array.\n             *\n             * TODO: All round() operations need to be reviewed; at the very least, some degree of control\n             * over the amount of rounding must eventually be provided.  Some minimum amount of rounding\n             * is required, because the BigNumber library doesn't provide any automatic precision control.\n             * Without rounding, these values quickly amass huge numbers of digits, and we die.\n             */\n            let a = new BigNumber(0), b = new BigNumber(0), as = new BigNumber(0), bs = new BigNumber(0);\n            do {\n                b = a.times(b).times(2).plus(y).round(20);\n                a = as.minus(bs).plus(x);\n                as = a.times(a).round(20);\n                bs = b.times(b).round(20);\n            } while (--n > 0 && as.plus(bs).lt(4));\n            if (n && aResults) {\n                let l = 4;  // iterate a few (4) more times to provide more detail; see http://linas.org/art-gallery/escape/escape.html\n                do {\n                    b = a.times(b).times(2).plus(y).round(20);\n                    a = as.minus(bs).plus(x);\n                    as = a.times(a).round(20);\n                    bs = b.times(b).round(20);\n                } while (--l > 0);\n                aa = as.toNumber();\n                bb = bs.toNumber();\n            }\n        }\n        /*\n         * If a results array is provided, we fill it in with:\n         *\n         *      [0]: the number of iterations specified (ie, the maximum)\n         *      [1]: the number of iterations remaining (if 0, then presumed to be in the Mandelbrot set)\n         *      [2]: the last square calculated for the real portion of the last z\n         *      [3]: the last square calculated for the imaginary portion of the last z\n         *\n         * Callers generally only care about the second value (which is the same as the function's return value),\n         * but all four values provide additional information about \"how close\" the number is to the Mandelbrot set.\n         */\n        if (aResults) {\n            aResults[0] = nMax;\n            aResults[1] = n;\n            aResults[2] = aa;\n            aResults[3] = bb;\n        }\n        return n;\n    }\n\n    /**\n     * getColor(palette, aResults)\n     *\n     * Adapted from code in https://github.com/cslarsen/mandelbrot-js/blob/master/mandelbrot.js\n     * Copyright 2012 Christian Stigen Larsen.\n     * Licensed in compliance with Apache License, Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0).\n     *\n     * @param {number} palette\n     * @param {Array.<number>} aResults\n     * @return {number}\n     */\n    static getColor(palette, aResults)\n    {\n        let rgb = 0;            // 0 is black (0x000000), used for numbers in the Mandelbrot set\n\n        if (aResults[1]) {      // if the number is NOT in the Mandelbrot set, then choose another color\n\n            let fSwap = true;\n            let v = Mandelbot.getSmoothColor(aResults);\n\n            switch (palette) {\n            case Mandelbot['PALETTE']['BW']:\n            default:\n                rgb = -1;       // -1 is white (0xffffff)\n                break;\n            case Mandelbot['PALETTE']['GRAY']:\n                v = Math.floor(512.0 * v / aResults[0]);\n                if (v > 0xff) v = 0xff;\n                rgb = v | (v << 8) | (v << 16);\n                break;\n            case Mandelbot['PALETTE']['BRIGHT']:\n                rgb = Mandelbot.getRGBFromHSV(360 * v / aResults[0], 1.0, 1.0);\n                break;\n            case Mandelbot['PALETTE']['MUTED']:\n                fSwap = false;\n                /* falls through */\n            case Mandelbot['PALETTE']['BLUE']:\n                rgb = Mandelbot.getRGBFromHSV(360 * v / aResults[0], 1.0, 10.0 * v / aResults[0]);\n                if (fSwap) {    // swap red and blue bytes\n                    rgb = (rgb & 0xff00ff00) | ((rgb >> 16) & 0xff) | ((rgb & 0xff) << 16);\n                }\n                break;\n            }\n        }\n        return rgb;\n    }\n\n    /**\n     * getMaxIterations(dxCenter, dyCenter)\n     *\n     * Adapted from code in https://github.com/cslarsen/mandelbrot-js/blob/master/mandelbrot.js\n     * Copyright 2012 Christian Stigen Larsen.\n     * Licensed in compliance with Apache License, Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0).\n     *\n     * @param {number|BigNumber} dxCenter\n     * @param {number|BigNumber} dyCenter\n     * @return {number}\n     */\n    static getMaxIterations(dxCenter, dyCenter)\n    {\n        let nMin;\n        if (typeof dxCenter == \"number\") {\n            nMin = Math.min(dxCenter, dyCenter);\n        } else {\n            nMin = BigNumber.min(dxCenter, dyCenter);\n        }\n        return Math.floor(223.0 / Math.sqrt(0.001 + 4.0 * nMin));\n    }\n\n    /**\n     * getRGBFromHSV(h, s, v)\n     *\n     * Adapted from hsv_to_rgb() in https://github.com/cslarsen/mandelbrot-js/blob/master/mandelbrot.js\n     * Copyright 2012 Christian Stigen Larsen.\n     * Licensed in compliance with Apache License, Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0).\n     *\n     * @param {number} h (0 to 360)\n     * @param {number} s (0.0 to 1.0)\n     * @param {number} v (0.0 to 1.0)\n     * @return {number}\n     */\n    static getRGBFromHSV(h, s, v)\n    {\n        if (v > 1.0) v = 1.0;\n\n        let hp = h / 60.0;\n        let c = v * s;\n        let x = c * (1 - Math.abs((hp % 2) - 1));\n\n        let r = 0, g = 0, b = 0;\n        if (hp < 1) {\n            r = c; g = x;\n        } else if (hp < 2) {\n            r = x; g = c;\n        } else if (hp < 3) {\n            g = c; b = x;\n        } else if (hp < 4) {\n            g = x; b = c;\n        } else if (hp < 5) {\n            r = x; b = c;\n        } else {\n            r = c; b = x;\n        }\n\n        let m = v - c;\n        r = (r + m) * 255;\n        g = (g + m) * 255;\n        b = (b + m) * 255;\n\n        return (r & 0xff) | ((g & 0xff) << 8) | ((b & 0xff) << 16);\n    }\n\n    /**\n     * getSmoothColor(aResults)\n     *\n     * Adapted from smoothColor() in https://github.com/cslarsen/mandelbrot-js/blob/master/mandelbrot.js\n     * Copyright 2012 Christian Stigen Larsen.\n     * Licensed in compliance with Apache License, Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0).\n     *\n     * @param {Array.<number>} aResults\n     * @return {number}\n     */\n    static getSmoothColor(aResults)\n    {\n        let n = aResults[0] - aResults[1];\n        return 5 + n - Mandelbot.LOG_HALFBASE - Math.log(Math.log(aResults[2] + aResults[3])) * Mandelbot.LOG_BASE;\n    }\n}\n\n/*\n * Various Mandelbot defaults, used primarily by the constructor, as well as the onReset() function\n */\nMandelbot.DEFAULT = {\n    WGRID:      200,\n    HGRID:      200,\n    XCENTER:    -0.65,\n    YCENTER:    0,\n    DXCENTER:   1.5,\n    DYCENTER:   1.5\n};\n\n/*\n * Various Mandelbot actions; see processSelectAction()\n */\nMandelbot.ACTION = {\n    PRESS:      1,      // eg, an action triggered by a 'mousedown' or 'touchstart' event\n    MOVE:       2,      // eg, an action triggered by a 'mousemove' or 'touchmove' event\n    RELEASE:    3       // eg, an action triggered by a 'mouseup' (or 'mouseout') or 'touchend' event\n};\n\nMandelbot.LOG_BASE = 1.0 / Math.log(2.0);\nMandelbot.LOG_HALFBASE = Math.log(0.5) * Mandelbot.LOG_BASE;\n\n/*\n * Various Mandelbot parameters that we support encoding in the hash ('#') portion of the URL; see updateHash()\n */\nMandelbot.KEY = {\n    ID:         \"id\",\n    XCENTER:    \"x\",\n    YCENTER:    \"y\",\n    DXCENTER:   \"dx\",\n    DYCENTER:   \"dy\",\n    BIGNUMBERS: \"big\",\n    PALETTE:    \"palette\"\n};\n\n/*\n * Various Mandelbot palettes supported\n */\nMandelbot['PALETTE'] = {\n    'BW':       1,  // B&W\n    'GRAY':     2,  // GRAYSCALE\n    'BRIGHT':   3,  //\n    'MUTED':    4,  //\n    'BLUE':     5,  //\n};\n\n/*\n * Various Mandelbot display shapes supported\n */\nMandelbot['SHAPE'] = {\n    'RECT':     0,\n    'CIRCLE':   1\n};\n\nMandelbot['CONTROL_DOWNLOAD'] = \"download\";\nMandelbot['CONTROL_STATUS']   = \"status\";\nMandelbot['CONTROL_RESET']    = \"reset\";\nMandelbot['CONTROL_PREVIOUS'] = \"previous\";\nif (DEBUG) Mandelbot['CONTROL_DEBUG'] = \"debug\";\n\nnMaxIterationsPerTimeslice = Mandelbot.calibrate(0, 8);\nnMaxBigIterationsPerTimeslice = Mandelbot.calibrate(0, 8, true);\n\n/**\n * newMandelbot(widthGrid, heightGrid, xCenter, yCenter, dxCenter, dyCenter, bigNumbers, palette, shape, idView, idStatus, fAutoUpdate)\n *\n * Global function for creating new Mandelbots.\n *\n * @param {number} [widthGrid]\n * @param {number} [heightGrid]\n * @param {number|string|undefined} [xCenter]\n * @param {number|string|undefined} [yCenter]\n * @param {number|string|undefined} [dxCenter]\n * @param {number|string|undefined} [dyCenter]\n * @param {boolean} [bigNumbers]\n * @param {number|undefined} [palette]\n * @param {number|undefined} [shape]\n * @param {string} [idView]\n * @param {string} [idStatus]\n * @param {boolean} [fAutoUpdate] (true to add the Mandelbot to the set of automatically updated Mandelbots)\n * @return {Mandelbot}\n */\nfunction newMandelbot(widthGrid, heightGrid, xCenter, yCenter, dxCenter, dyCenter, bigNumbers, palette, shape, idView, idStatus, fAutoUpdate = true)\n{\n    let mandelbot = new Mandelbot(widthGrid, heightGrid, xCenter, yCenter, dxCenter, dyCenter, bigNumbers, palette, shape, idView, idStatus);\n    if (fAutoUpdate) addMandelbot(mandelbot);\n    return mandelbot;\n}\n\n/**\n * addMandelbot(mandelbot)\n *\n * Adds the Mandelbot to the array of auto-updated Mandelbots.  newMandelbot() does this by default.\n *\n * @param {Mandelbot} mandelbot\n */\nfunction addMandelbot(mandelbot)\n{\n    activeMandelbots.push(mandelbot);\n    updateMandelbots(true);\n}\n\n/**\n * updateMandelbots(fInit)\n *\n * setTimeout() handler for updating all Mandelbots.  addMandelbot() does this automatically to ensure an update\n * has been scheduled.\n *\n * @param {boolean} [fInit] (true to merely schedule an update; otherwise, perform an update and then schedule another)\n */\nfunction updateMandelbots(fInit)\n{\n    if (!fInit) {\n        idTimeout = 0;\n        let nMandelbots = activeMandelbots.length;\n        while (nMandelbots--) {\n            let mandelbot = activeMandelbots[iNextMandelbot];\n            if (mandelbot.updateGrid()) {\n                /*\n                 * Since the grid was updated, we set the fInit flag to ensure that at least one more\n                 * updateMandelbots() call will be scheduled via setTimeout().  Even though it's possible\n                 * that the grid was FULLY updated, I'm happy to wait until the next updateMandelbots()\n                 * call to find that out; updateGrid() will then report there was nothing to update, and\n                 * once ALL the grids on the page report the same thing, we'll stop scheduling these calls.\n                 */\n                fInit = true;\n            }\n            if (++iNextMandelbot >= activeMandelbots.length) iNextMandelbot = 0;\n        }\n    }\n    /*\n     * Schedule a new call for immediate execution if there were any updates (otherwise, we assume our work is done).\n     */\n    if (fInit && !idTimeout) {\n        idTimeout = setTimeout(updateMandelbots, 0);\n    }\n}\n\n/*\n * Closure Compiler \"hacks\" to prevent the renaming of classes, methods, and functions we want to export\n */\nwindow['Mandelbot'] = Mandelbot;\nMandelbot.prototype['addControl'] = Mandelbot.prototype.addControl;\nwindow['newMandelbot'] = newMandelbot;\n"]}