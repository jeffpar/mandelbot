/* mbrot.c  v3.10
 *
 * Original program (3.00) by Jeff Parsons  8/86
 * Original recursive algorithm by Bill Mershon  8/86
 *
 * Graphs regions in and around the Mandelbrot set,
 * as outlined in the August '85 issue of Scientific American.
 * Supports all common IBM display modes, using CGA or EGA adapters.
 *
 * Present limitations (based on features listed below):
 *	Not all options implemented
 *	Recursive algorithm not implemented
 *	Not all supported hardware configurations tested
 *	Graphics support still needs some speed optimizations
 *
 * Usage:  mbrot [graph-file] [options...]
 *	Graph-file is the name of a file to create or restore from
 *	(depending on whether the -c option is present or not);  if
 *	not given, it will be prompted for;  the graph-file need
 *	not precede the options (that is up to the user's preference).
 *	If the graph-file, when opened, is determined to be an image-
 *	library-file, then an automatic image-by-image restore is done, so
 *	options i,c,x,y,w,p,m,l would be ignored (see below for more info).
 *
 * Options (/ may be used instead of -):
 *	-h	lists program usage and options;
 *	-l	selects resident (background) operation;
 *	-ec	allows EGA display modes, in
 *		the event EGA capability is not detected;  c
 *		should either be 'c'(color) or 'm'(monochrome);
 *	-b	selects "batch" mode, under which all user-interaction
 *		is avoided;  otherwise, required values will be prompted
 *		for if not known, and the graphics-interface menu (not
 *		yet designed) made available (on completion of a graph);
 *	-n	inhibits graph display during computation, which normally
 *		occurs only when -l option selected;
 *	-kstrng	selects the colors to be used;  format of strng is
 *		<color-code><intensity-value>..., where <color-code> is
 *		B(black), b(blue), g(green), c(cyan), r(red), m(magenta),
 *		o(orange), or w(white);  <intensity-value> is a digit 1-8;
 *		the first code/value is reserved for the color of Mandelbrot
 *		points;  (example: B1u1u2g1c1r1m1o1w1 selects black for
 *		Mandelbrot points and eight other colors, repeated as needed);
 *		maximum colors allowed following Mandelbrot color: 15 +
 *		optional border color;
 *	-j#	selects color granularity (# of iterations spanned per
 *		color);  default is 1;
 *	-c	selects CREATE mode, for which the values listed
 *		below are needed (otherwise they will be prompted for);
 *		without this option, the program is in RESTORE mode,
 *		and expects to be given a graph-file to read from;
 *		note that in "batch" mode, to create to an existing file,
 *		(or to restore from a non-existent file) is a fatal error;
 *	-cu	same as -c, but is UNCONDITIONAL (ie, if graph-file exists,
 *		it will be deleted first);
 *	-ifile	specifies an image-library-file to add the image to
 *		once it has been created (or restored), which contains
 *		images stored in a format suitable for rapid video display;
 *		if not given, it will be prompted for, but it will not be
 *		required;
 *	-v	causes the program to wait for a keyboard response
 *		after restoring each frame of an image-library-file;
 *	-x#.#	specifies x (real) co-ordinate of graph center,
 *		where #.# represents any legal floating-point constant;
 *	-y#.#	specifies y (imaginary) co-ordinate of graph center;
 *	-w#.#	specifies the (real) width of the graph;
 *		the (imaginary) height will be the width * RATIO;
 *	-p#	specifies the percentage of the total screen area to be
 *		used for the graph;  default is 100%
 *	-r#.#	specifies vertical/horizontal ratio;  default is RATIO;
 *	-g#	specifies the graphics display mode to be used:
 *		1 =  4-color Low-res  (CGA/EGA)
 *		2 =  2-color Med-res  (CGA/EGA)
 *		3 = 16-color Low-res  (EGA)
 *		4 = 16-color Med-res  (EGA)
 *		5 = 16-color 640x350  (EGA w/Enhanced Display)
 *		6 = 16-color 640x480  (EVA w/MultiSync Display)
 *		Note: since EGA colors are selected from a 64-color palette,
 *		colors appearing on an Enhanced Display may differ from
 *		those seen on a normal IRGB Color Display (unless a different
 *		coloring scheme is selected with the k option); default
 *		value depends on equipment installed;
 *	-m#	specifies the algorithm limit (defaults to 250, usual
 *		limits are 100 to 64k);
 *	-f#	forces the data storage format # (defaults to COMPACT);
 *	-s	specifies "sequential" (or standard iterative) algorithm;
 *		if omitted, then the *new* recursive algorithm will be used
 *		(which analyzes borders of successive block-divisions of the
 *		screen);  the output using either method should be identical;
 *
 * Errorlevels (currently):
 *	1. Signal abort
 *	2. File open/create error
 *
 * Examples:
 *	mbrot mbrot.1 -c -x -1.25 -y0 -w2.5 -i mbrot.mem
 */


/*** Include files ***/

#define	LINT_ARGS  1		/* enable argument checking */

#include <dos.h>
#include <conio.h>
#include <io.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <signal.h>
#include <string.h>
#ifdef	PROTECT
#include <subcalls.h>
#endif
#ifndef	SEEK_CUR
#define	SEEK_SET 0
#define	SEEK_CUR 1
#endif


/*** New type identifiers ***/

typedef	unsigned char Byte;
typedef unsigned Word;
typedef	unsigned long Dword;


/*** Manifest constants ***/

#define	TRUE	1
#define	FALSE	0
#define	NONE	0xff
#define	RATIO	0.7		/* vertical/horiz ratio (aspect?) */
#define	MAXPOINTS 65536/sizeof(int)
#define	OLD_METHOD	0	/* method codes stored in graph-files */
#define	COMPACT_METHOD	1
#define	KNOWN_METHOD	1

#define	ESCAPE	27		/* popular ascii codes */

#define	MOUSE		0x01
#define	RIGHTBUTTON	0x02
#define	LEFTBUTTON	0x04	/* our mouse status bit definitions */

#define	MOUSE_EXIT	1	/* our mouse-routine return codes */
#define	MOUSE_GO	2


/*** Graphics-related constants & data */

#define	MAX_MODES	 6	/* maximum supported by program */
#define	TOTAL_MODES	 3	/* maximum supported by video routines */

#define	TEXT80_EGAH	 0	/* common ega modes (internal mode #s) */
#define	GRAPH640x350_64	 1
#define	GRAPH640x350_256 2
#define	GRAPH640x480_256 3
#define	GRAPH320x200_4	 4	/* other common graphics mode possibilities */
#define	GRAPH640x200_2	 5
#define	GRAPH320x200_16	 6
#define	GRAPH640x200_16	 7
#define	TEXT80_EGAM	 8

Byte IBMmode[] = {0x03,		/* use IBMmode[internalmode] for ibm values */
		  0x10,
		  0x10,
		  0x25,
		  0x04,
		  0x06,
		  0x0D,
		  0x0E,
		  0x07};
Byte Videomode = TEXT80_EGAH;	/* used to track internal mode */
Byte far *Videoaddr = (Byte far *)(0xA0000000l);

#define	MISC_OUT	0x3C2	/* ega external registers */
Word	Feat_reg =	0x3DA;
#define	SEQ_ADDR	0x3C4	/* ega sequencer registers */
#define	SEQ_DATA	0x3C5
Word	Crt_addr =	0x3D4;	/* ega crt controller registers */
Word	Crt_data =	0x3D5;
#define	GR1_POS		0x3CC	/* ega graphics controller registers */
#define	GR2_POS		0x3CA
#define	GRC_ADDR	0x3CE
#define	GRC_DATA	0x3CF
#define	ATT_CONT	0x3C0	/* ega attribute controller port */

#define	MIN_EGAPORT	0x3B0
#define	MAX_EGAPORT	0x3DF


/*** Global constants ***/

char	*title  = "Mandelbrot Microscope\n";
char	*ver    = "Version 3.10 by Jeff Parsons  March, 1987\n";

double	zero = 0.0;


/*** Global inputs ***/

double	xcenter = -0.75,	/* (x,y) co-ordinates of graph center */
	ycenter = 0.0,
	xsize = 3.25,		/* width of image, along x (real) axis */
	percentage = 100.0,	/* percentage of screen area to use */
	oldpercentage,
	yfactor = RATIO;	/* ysize will be (xsize * yfactor)
				   to compensate for rectangular screen */
unsigned graphmode = 1,		/* see list of graph mode #'s above */
	 oldgraphmode,		/* saved by prep_graph */
	 desiredmode = 0,
	 maxcount = 250,
	 colorjump = 0,
	 uniquecolors = 15,
	 mouse = 0,		/* bits 1&2(+3&4) are right&left buttons */
	 hmousepos, vmousepos,
	 hboxpos, vboxpos,	/* all positions are relative to 1 */
	 hboxend = 0, vboxend = 0;

Byte	boxarray[640*2+480*2];	/* enough room for biggest possible box */

Byte	cgapalette = 0,		/* palette code (for CGA modes only) */
	cgaborder = 0;		/* CGA border (or 1-color graphics color) */

char	*colorlist = NULL,	/* pointer set to color-list, if any */
	graphname[80] = "",	/* graph-file name */
	imagename[80] = "";	/* image-library-file name */


/*** Global calculations ***/

Byte	egamode = 0,		/* 1=color, 2=enhanced, 3=monochrome, 4=eva */
	egasize = 0,		/* # of 64k chunks installed */
	egabits = 0,		/* ega feature bits */
	egasets = 0,		/* ega switch settings */
	method = COMPACT_METHOD;

Byte	oldmode = NONE;		/* mode to restore upon program termination */

int	vwidth, vheight,	/* width & height of screen in pixels */
	hsize, vsize,		/* width & height of image on screen */
	rheight, rsize,		/* real vertical dimensions */
	hoffset, voffset,
	duptotal = 0,
	dupvalue = 0,		/* values kept for compact data expansion */
	comptotal = 0,
	compvalue = 0;		/* values kept for file compression */

long	comppos;		/* if compressing, file position */

double	ysize,			/* height of image (see yfactor) */
	xgap, ygap;		/* x and y deltas from point to point */


/*** Other Global data ***/

FILE	*graphfile = NULL,
	*imagefile = NULL;

Byte	vtable[MAX_MODES] = {GRAPH320x200_4,
			     GRAPH640x200_2,
			     GRAPH320x200_16,
			     GRAPH640x200_16,
			     GRAPH640x350_256,
			     GRAPH640x480_256};
int	utable[MAX_MODES] = {4, 2, 16, 16, 16, 16};	/* unique colors/mode */
char	ktable[8] = {'B', 'b', 'g', 'c', 'r', 'm', 'o', 'w'};
Byte	ptable[17] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
		      0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0};

unsigned *screen = NULL;	/* pixel matrix pointer (array of points) */

struct {unsigned title : 1;
	unsigned error : 1;
	unsigned help : 1;
	unsigned debug : 1;
	unsigned ega : 1;
	unsigned batch : 1;
	unsigned nodisp : 1;
	unsigned alternate : 1;
	unsigned time : 1;
	unsigned create : 1;
	unsigned ucreate : 1;
	unsigned std : 1;
	unsigned pause : 1;
	unsigned x : 1;
	unsigned y : 1;
	unsigned size : 1;
	unsigned count : 1;
	unsigned percent : 1;
	unsigned ratio : 1;
	unsigned mode : 1;
	unsigned method : 1;
	unsigned compact : 1;
	unsigned dirty : 1;
	unsigned critical : 1;
	} flags;


/*** External declarations ***/

#ifdef	DOS386
extern void far pascal ioreq(Word, Word);
extern void far pascal iofree(Word, Word);
#else
#define	ioreq(a,b)
#define	iofree(a,b)
#endif
extern Word far pascal inw(Word);
extern Byte far pascal inb(Word);
extern void far pascal outw(Word, Word);
extern void far pascal outb(Word, Byte);
extern void far pascal outb2(Word, Byte, Byte);


/*** Forward declarations ***/

void	do_title(void);
void	sig_handler(void);
Byte	video_mode(void);
void	get_ega(void);
void	set_video(Byte);
void	set_palette(void);
void	display_type(void);

void	init_mouse(void);
void	show_mouse(void);
void	hide_mouse(void);
int	process_events(void);
int	mouse_movement(void);
int	mouse_moved(void);
int	mouse_leftdown(void);
int	mouse_leftup(void);
int	mouse_rightdown(void);
int	mouse_rightup(void);
void	draw_box(Byte, Byte);
void	draw_point(int, int, int *, Byte);

void	get_unknowns(void);
void	parse_colors(char *);
void	open_graph(void);
void	read_header(void);
void	write_header(void);

void	prep_graph(void);
unsigned get_count(void);
void	put_count(unsigned);
void	do_graph(void);
void	write_point(unsigned, unsigned, int);
Byte	read_dot(unsigned, unsigned);
void	write_dot(unsigned, unsigned, Byte);

void	get_switches(int, char **);
void	help(void);
void	clr_kbd(void);
void	press_key(void);
char	inp_char(void);
int	inp_line(char *, double *);

void	setvideo(Byte);
void	disable_video(void);
void	enable_video(void);
void	setega_extregs(Byte);
void	setega_seqregs(Byte);
void	setega_crtregs(Byte);
void	setega_grcregs(Byte);
void	setega_attregs(Byte);


void main(argc, argv, envp)
int	argc;
char	**argv, **envp;
{
	signal(SIGINT, sig_handler);	/* trap ctrl-c/break */
	get_switches(--argc, ++argv);
	display_type();			/* determine type of display */
	if (!flags.batch)
		get_unknowns();		/* get any unspecified variables */
	else if (graphname[0])
		open_graph();		/* try open even if batch */
	if (colorlist)
		parse_colors(colorlist);
	prep_graph();			/* get video parameters for graph */
	while (TRUE) {
		if (flags.create && graphfile)	/* save info in file, if any */
			write_header();
		if (!flags.nodisp) {
			flags.dirty = FALSE;
			/*set_video(vtable[graphmode-1]);*/
			if (colorlist)
				set_palette();
		}
		while (TRUE) {
			do_graph();		/* start graphing */
			if (!flags.create && graphfile) {
				getc(graphfile);
				if (!feof(graphfile)) {
					fseek(graphfile, -1l, SEEK_CUR);
					flags.dirty = TRUE;
					read_header();
					continue;
				}
				else {
					flags.create = TRUE;
					clearerr(graphfile);
					fseek(graphfile, 0l, SEEK_CUR);
				}
			}
			break;
		}
		if (!flags.nodisp) {
			init_mouse();
			clr_kbd();
			if (!process_events()) {
				set_video(oldmode);
				break;
			}
		}
		else
			break;		/* if not displaying, kick out of loop */
	}
	if (graphfile) {
		if (flags.compact)
			chsize(fileno(graphfile), comppos);
		fclose(graphfile);
	}
	exit(0);			/* then normal exit */
}


void do_title()
{
	if (!flags.title) {
		printf("%s%s\n", title, ver);
		flags.title = TRUE;
	}
}


void sig_handler()
{
	if (flags.critical)
		signal(SIGINT, sig_handler);
	else {
		if (oldmode != NONE && oldmode != video_mode())
			set_video(oldmode);
		if (graphfile) {
			if (flags.compact)
				chsize(fileno(graphfile), comppos);
			fclose(graphfile);
		}
		if (imagefile)
			fclose(imagefile);
		_exit(1);
	}
}


Byte video_mode()
{
	register Byte i;
	union REGS regs;

	#ifdef	PROTECT
	return(Videomode);
	#else
	regs.h.ah = 0x0F;	/* video function 0F: get video state */
	int86(0x10, &regs, &regs);
	for (i=0; i<sizeof(IBMmode); i++)
		if (regs.h.al == IBMmode[i])
			return(i);
	return(0);
	#endif
}


void get_ega()
{
	union REGS regs;
	char far *romaddr;
	register int i;
	char romstring[6];

	#ifdef	PROTECT
	regs.h.bl = 3;		/* assume max ega memory */
	regs.h.bh = 0;		/* assume color mode */
	regs.h.cl = 0x07;	/* assume these switch settings */
	regs.h.ch = 0x0F;	/* assume these feature bits */
	#else
	regs.h.ah = 0x12;	/* video function 12: alternate fn select */
	regs.h.bl = 0x10;	/* # to request ega info */
	int86(0x10, &regs, &regs);
	#endif

	if (regs.h.bl <= 3 && regs.h.bh <= 1) {
		egamode = ++regs.h.bh;	/* return ega info */
		egasize = ++regs.h.bl;	/* in global calculation area */
		egabits = regs.h.ch;
		egasets = regs.h.cl;
	}
	else if (flags.ega) {	/* egamode explicitly specified */
		egasize = 1;
		egabits = 0x0F;
		if (egamode == 1)
			egasets = 0x07;
		else
			egasets = 0x0B;
	}
	if (egamode == 1 && (egasets == 0x08 || egasets == 0x09) ||
	    egamode == 2)
		egamode++;	/* adjust egamode to value from 1 to 3 */

	#ifndef	PROTECT
	if (egamode) {		/* can do this only in real mode */
		romaddr = (char far *)0xC0000076l;
		for (i=0; i<=4; i++)
			romstring[i] = *romaddr++;
		romstring[5] = '\0';
		if (!strcmp(romstring, "Tseng"))
			egamode += 2;
	}
	#endif

	if (!flags.mode)
		if (egamode == 1)	/* ega but with rgb monitor */
			graphmode = 4;
		else
		if (egamode >= 2 && egamode <= 3)
			graphmode = 5;	/* enhanced color supports 640x350 */
		else {
			graphmode = 6;	/* Tseng Eva/480 board sports 640x480 */
			yfactor = 0.75;	/* square pixel, so ratio exactly 480/640 */
		}
}


void set_video(newmode)
Byte	newmode;
{
	union REGS regs;

	#ifdef	PROTECT
	setvideo(newmode);
	Videomode = newmode;
	#else
	regs.x.ax = IBMmode[newmode];
	int86(0x10, &regs, &regs);
	#endif
}


void set_palette()
{
	union REGS regs;

	#ifndef	PROTECT
	if (egamode) {		/* video function 10/02: set all colors */
		regs.x.ax = 0x1002;
		regs.x.dx = (int)ptable;
		int86(0x10, &regs, &regs);
	}
	#endif
}


void display_type()
{
	register char *p;

	oldmode = video_mode();
	get_ega();
	if (!flags.batch) {
		if (!egamode)
			if (oldmode == TEXT80_EGAM)
				p = "Monochrome";
			else
				p = "Color w/CGA";
		else if (egamode == 1)
			p = "Color w/EGA";
		else if (egamode == 2)
			p = "Enhanced Color";
		else if (egamode == 3)
			p = "Monochrome w/EGA";
		else if (egamode >= 4 && egamode <= 5)
			p = "MultiSync w/EVA";
		else {
			p = "Unknown [ ]";
			*(p+9) = (char)('0'+egamode);
		}
		do_title();
		printf("Display type: %s", p);
		if (egamode)
			printf(" (%dk)", egasize*64);
		printf("\n\n");
	}
}


void init_mouse()
{
	union REGS regs;
	Dword far *p = (Dword far *)(0x33*4);

	#ifndef	PROTECT
	if (!*p)
		return;		/* no mouse vector address */
	regs.x.ax = 0;
	int86(0x33, &regs, &regs);
	if (!regs.x.ax)		/* no mouse driver */
		return;
	mouse = MOUSE;		/* assume exists for now */
	regs.x.ax = 7;		/* set min/max horizontal positions */
	regs.x.cx = hoffset;
	regs.x.dx = hoffset+(hsize-3);
	int86(0x33, &regs, &regs);
	regs.x.ax = 8;		/* set min/max vertical position */
	regs.x.cx = voffset;
	regs.x.dx = voffset+(rsize-3);
	int86(0x33, &regs, &regs);
	regs.x.ax = 4;		/* set mouse position */
	hmousepos = hsize/2;
	vmousepos = rsize/2;
	regs.x.cx = hmousepos++ + hoffset;
	regs.x.dx = vmousepos++ + voffset;
	int86(0x33, &regs, &regs);
	show_mouse();
	#endif
}


void show_mouse()
{
	union REGS regs;

	#ifndef	PROTECT
	regs.x.ax = 1;		/* show mouse pointer now */
	int86(0x33, &regs, &regs);
	#endif
}


void hide_mouse()
{
	union REGS regs;

	#ifndef	PROTECT
	regs.x.ax = 2;		/* hide mouse pointer now */
	int86(0x33, &regs, &regs);
	#endif
}


int process_events()
{
	register int c;
	union REGS regs;

	while (TRUE) {
		while (kbhit()) {
			if ((c=getch()) == ESCAPE)
				return(FALSE);	/* we're done */
		}
		if (mouse) {
			#ifndef	PROTECT
			regs.x.ax = 3;		/* get mouse position */
			int86(0x33, &regs, &regs);
			c = regs.x.bx;		/* button status */
			regs.x.cx -= (hoffset-1);
			regs.x.dx -= (voffset-1);
			#endif
			if (c & 0x01) {
				mouse |= LEFTBUTTON;
				if (!(mouse & (LEFTBUTTON<<2))) {
					mouse |= (LEFTBUTTON<<2);
					mouse_leftdown();
				}
			}
			else {
				mouse &= ~LEFTBUTTON;
				if (mouse & (LEFTBUTTON<<2)) {
					mouse &= ~(LEFTBUTTON<<2);
					mouse_leftup();
				}
			}
			if (c & 0x02) {
				mouse |= RIGHTBUTTON;
				if (!(mouse & (RIGHTBUTTON<<2))) {
					mouse |= (RIGHTBUTTON<<2);
					c = mouse_rightdown();
					if (c == MOUSE_EXIT)
						return(FALSE);
					else if (c == MOUSE_GO)
						return(TRUE);
				}
			}
			else {
				mouse &= ~RIGHTBUTTON;
				if (mouse & (RIGHTBUTTON<<2)) {
					mouse &= ~(RIGHTBUTTON<<2);
					mouse_rightup();
				}
			}
			if (regs.x.cx != hmousepos || regs.x.dx != vmousepos) {
				hmousepos = regs.x.cx;
				vmousepos = regs.x.dx;
				mouse_moved();
			}
		}
	}
}


int mouse_movement()
{
	union REGS regs;

	#ifndef	PROTECT
	regs.x.ax = 3;		/* check mouse position */
	int86(0x33, &regs, &regs);
	regs.x.cx -= (hoffset-1);
	regs.x.dx -= (voffset-1);
	if (regs.x.bx & 0x01)	/* if left button still down */
		if (regs.x.cx != hmousepos || regs.x.dx != vmousepos)
			return(TRUE);
	#endif
	return(FALSE);
}


int mouse_moved()
{
	if (mouse & LEFTBUTTON) {	/* if left button still down */
		draw_box(FALSE, 4);	/* erase any previous box */
		hboxend = hmousepos;
		vboxend = vmousepos;	/* define endpoints as new position */
		if (abs(hboxend-hboxpos) < 2)
			if (hboxend >= hboxpos)
				hboxend = hboxpos + 2;
			else
				hboxend = hboxpos - 2;
		if (abs(vboxend-vboxpos) < 2)
			if (vboxend >= vboxpos)
				vboxend = vboxpos + 2;
			else
				vboxend = vboxpos - 2;
		draw_box(TRUE, 4);	/* redraw a box */
	}
	return(0);
}


int mouse_leftdown()
{
	draw_box(FALSE, 4);	/* erase any previous box */
	hboxpos = hmousepos;	/* denoted by nonzero endpoints */
	vboxpos = vmousepos;	/* then record new beginpoints (upper-left) */
	hboxend = 0;
	vboxend = 0;		/* so that erase will know there's nothing */
	return(mouse_moved());
}


int mouse_leftup()
{
	return(0);
}


int mouse_rightdown()
{
	register int newsize, newcenter;

	if (hboxend == 0)
		return(MOUSE_EXIT);
	else {			/* compute new boundaries and width */
		newsize = abs(hboxend-hboxpos);
		if (hboxpos <= hboxend)
			newcenter = hboxpos + newsize/2;
		else
			newcenter = hboxend + newsize/2;
		xcenter += (newcenter - hsize/2) * xgap;
		newsize = abs(vboxend-vboxpos);
		if (vboxpos <= vboxend)
			newcenter = vboxpos + newsize/2;
		else
			newcenter = vboxend + newsize/2;
		ycenter += (vsize/2 - newcenter) * ygap;
		xsize = (xsize * abs(hboxend-hboxpos)) / hsize;
		hboxend = 0;
		vboxend = 0;
		return(MOUSE_GO);
	}
}


int mouse_rightup()
{
	return(0);
}


void draw_box(draw, sides)
Byte draw, sides;
{
	int b=0;
	register int xi, yi;

	if (!draw)
		if (hboxend == 0 || vboxend == 0)
			return;
	hide_mouse();
	if (hboxpos <= hboxend)
		for (xi=hboxpos,yi=vboxpos; xi<=hboxend; xi++)
			draw_point(xi, yi, &b, draw);
	else
		for (xi=hboxpos,yi=vboxpos; xi>=hboxend; xi--)
			draw_point(xi, yi, &b, draw);
	if (!--sides) {
		hboxend = 0;
		goto end;
	}
	if (draw && mouse_movement()) {
		draw_box(FALSE, 1);
		goto end;
	}
	if (vboxpos <= vboxend)
		for (xi=hboxend,yi=vboxpos+1; yi<=vboxend; yi++)
			draw_point(xi, yi, &b, draw);
	else
		for (xi=hboxend,yi=vboxpos-1; yi>=vboxend; yi--)
			draw_point(xi, yi, &b, draw);
	if (!--sides) {
		hboxend = 0;
		goto end;
	}
	if (draw && mouse_movement()) {
		draw_box(FALSE, 2);
		goto end;
	}
	if (hboxpos <= hboxend)
		for (xi=hboxend-1,yi=vboxend; xi>=hboxpos; xi--)
			draw_point(xi, yi, &b, draw);
	else
		for (xi=hboxend+1,yi=vboxend; xi<=hboxpos; xi++)
			draw_point(xi, yi, &b, draw);
	if (!--sides) {
		hboxend = 0;
		goto end;
	}
	if (draw && mouse_movement()) {
		draw_box(FALSE, 3);
		goto end;
	}
	if (vboxpos <= vboxend)
		for (xi=hboxpos,yi=vboxend-1; yi>vboxpos; yi--)
			draw_point(xi, yi, &b, draw);
	else
		for (xi=hboxpos,yi=vboxend+1; yi<vboxpos; yi++)
			draw_point(xi, yi, &b, draw);
end:
	show_mouse();
}


void draw_point(xi, yi, b, draw)
register int xi, yi;
int *b;
Byte draw;
{
	if (!draw)
		write_dot(xi, yi, boxarray[(*b)++]);
	else if ((boxarray[(*b)++] = read_dot(xi, yi)) == 0x0f)
		write_dot(xi, yi, 0x00);
	else
		write_dot(xi, yi, 0x0f);
}


void get_unknowns()
{
	while (!graphfile) {
		if (!graphname[0]) {
			printf("Name of graph-file: ");
			if (inp_line("%79s", (double *)graphname) != 1) {
				putchar('\n');
				break;
			}
		}
		open_graph();
	}
	if (!flags.x) {		/* if xcenter not given as switch... */
		printf("X of center: ");
		flags.x = inp_line("%lf", &xcenter)==1;
	}
	if (!flags.y) {		/* similarly, if ycenter not known... */
		printf("Y of center: ");
		flags.y = inp_line("%lf", &ycenter)==1;
	}
	while (!flags.size) {	/* similarly, if xsize has not been set... */
		printf("Width of window: ");
		if (!(flags.size = inp_line("%lf", &xsize)==1))
			break;
		else if (xsize < zero)
			flags.size = FALSE;
	}
	while (!flags.count) {
		printf("Max iterations [%u]: ", maxcount);
		if (!(flags.count = inp_line("%u", (double *)&maxcount)==1))
			break;
		else if (maxcount == 0)
			flags.size = FALSE;
	}
	while (!flags.percent) {
		printf("Percentage of screen [%.0lf]: ", percentage);
		if (!(flags.percent = inp_line("%lf", &percentage)==1))
			break;
		else if (percentage <= zero || percentage > 100.0)
			flags.percent = FALSE;
	}
	while (!flags.ratio) {
		printf("Vertical/horizontal ratio [%.2f]: ", yfactor);
		if (!(flags.ratio = inp_line("%lf", &yfactor)==1))
			break;
		else if (yfactor <= zero || yfactor > 1.0)
			flags.ratio = FALSE;
	}
	while (!flags.mode) {
		printf("\n\
Display modes supported....\n\
  1.  4-color Low-res (CGA/EGA)\n\
  2.  2-color Med-res (CGA/EGA)\n\
  3. 16-color Low-res (EGA)\n\
  4. 16-color Med-res (EGA)\n\
  5. 16-color 640x350 (EGA+Enhanced)\n\
  6. 16-color 640x480 (EVA+MultiSync)\n\
Select one of these display modes [%u]: ", graphmode);
		if (!(flags.mode = inp_line("%u", (double *)&graphmode)==1))
			break;
		else if (graphmode == 0 || graphmode > MAX_MODES)
			flags.mode = FALSE;
	}
}


void parse_colors(s)
char *s;
{
	Byte error = FALSE;
	register int p, p2, i;

	p = 0;
	while (*s && p <= 16) {
		for (i=0; i<8; i++)
			if (*s == ktable[i])
				break;
		if (i == 8) {
			error = TRUE;
			break;
		}
		s++;
		if (*s < '1' || *s > '8') {
			error = TRUE;
			break;
		}
		i += (*s++ - '1')*8;	/* palette code assembled now */
		if (graphmode == 5 && egasize == 1) {
			if (p <= 3) {
				switch (p) {
				case 0:
					p2 = 0;
					break;
				case 1:
					p2 = 1;
					break;
				case 2:
					p2 = 4;
					break;
				case 3:
					p2 = 5;
					break;
				}
				ptable[p2] = ptable[p2+2] =
				ptable[p2+8] = ptable[p2+10] = (Byte)i;
			}
			else if (p == 16)
				ptable[p] = (Byte)i;
		}
		else
			ptable[p] = (Byte)i;
		p++;
	}
	if (error) {
		do_title();
		fprintf(stderr, "Bad color code: %c\n", *s);
		press_key();
	}
	else
		uniquecolors = --p;
}


void open_graph()
{
	char str[80];

	strupr(graphname);
	if (flags.create) {
		if (flags.ucreate) {
			if (!(graphfile=fopen(graphname, "wb"))) {
				flags.ucreate = FALSE;
				fprintf(stderr, "Cannot create file %s",
					graphname);
				if (flags.batch)
					_exit(2);
				fprintf(stderr, "\n\n");
				graphname[0] = '\0';
			}
			else
				fprintf(graphfile, "Requires %s%s\x1A",
					title, ver);
		}
		else {
			if (graphfile=fopen(graphname, "rb")) {
				fclose(graphfile);
				graphfile = NULL;
				fprintf(stderr, "File %s exists",
					graphname);
				if (flags.batch)
					_exit(2);
				fprintf(stderr, ", overwrite? ");
				if (inp_char() == 'y') {
					flags.ucreate = TRUE;
					open_graph();
				}
				else
					graphname[0] = '\0';
				putchar('\n');
			}
			else {
				flags.ucreate = TRUE;
				open_graph();
			}
		}
	}			/* create options taken care of now */
	else {
		graphfile=fopen(graphname, "r+b");
		if (!graphfile)
			graphfile=fopen(graphname, "rb");
		if (!graphfile) {
			fprintf(stderr, "File %s does not exist",
				graphname);
			if (flags.batch)
				_exit(2);
			fprintf(stderr, ", create? ");
			if (inp_char() == 'y') {
				flags.create = TRUE;
				open_graph();
			}
			else
				graphname[0] = '\0';
			putchar('\n');
		}
		else {
			fgets(str, 79, graphfile);
			if (strcmp(str+9, title) != 0) {
				fclose(graphfile);
				graphfile = NULL;
				fprintf(stderr, "Invalid graph file %s",
					graphname);
				if (flags.batch)
					_exit(2);
				fprintf(stderr, "\n\n");
				graphname[0] = '\0';
			}
			else {
				fgets(str, 79, graphfile);
				fgetc(graphfile);	/* skip EOF byte */
				read_header();
			}
		}
	}
}


void read_header()
{
	unsigned i;

	if (flags.mode)
		desiredmode = graphmode;
	fread((char *)&graphmode, sizeof(graphmode), 1, graphfile);
	cgapalette = (Byte)fgetc(graphfile);
	cgaborder = (Byte)fgetc(graphfile);
	fread((char *)&xcenter, sizeof(xcenter), 1, graphfile);
	fread((char *)&ycenter, sizeof(ycenter), 1, graphfile);
	fread((char *)&xsize, sizeof(xsize), 1, graphfile);
	fread((char *)&percentage, sizeof(percentage), 1, graphfile);
	fread((char *)&yfactor, sizeof(yfactor), 1, graphfile);
	fread((char *)&i, sizeof(i), 1, graphfile);
	if (!flags.count)
		maxcount = i;
	fread((char *)&i, sizeof(i), 1, graphfile);
	if (!colorjump)
		colorjump = i;
	fread((char *)&uniquecolors, sizeof(uniquecolors), 1, graphfile);
	fread((char *)ptable, sizeof(ptable), 1, graphfile);
	i = fgetc(graphfile);		/* method-code + extra-bytes */
	if (i == OLD_METHOD && flags.method && method == COMPACT_METHOD) {
		flags.compact = TRUE;
		fseek(graphfile, -1l, SEEK_CUR);
		fputc(method, graphfile);
		fseek(graphfile, 0l, SEEK_CUR);
	}
	method = (Byte)i;
	fread((char *)&i, sizeof(i), 1, graphfile);
	if (flags.compact)		/* save position at end of header */
		comppos = ftell(graphfile);

	flags.mode = flags.x = flags.y = flags.size =
		flags.percent = flags.ratio = flags.count = TRUE;

	if (!flags.batch && !flags.dirty) {
		printf("Graph mode: %u\n", graphmode);
		printf("Center x: %f\n", xcenter);
		printf("Center y: %f\n", ycenter);
		printf("Width: %f\n", xsize);
		printf("Percentage: %f\n", percentage);
		printf("Ratio: %f\n", yfactor);
		printf("Max iterations: %u\n", maxcount);
		printf("File format: ");
		if (method == COMPACT_METHOD)
			printf("Compressed\n");
		else
			printf("Uncompressed\n");
		press_key();
	}
	if (method > KNOWN_METHOD) {
		printf("Extended header unknown to this version\n");
		exit(2);
	}
}


void write_header()
{
	int i = 0;

	flags.critical = TRUE;
	fwrite((char *)&oldgraphmode, sizeof(oldgraphmode), 1, graphfile);
	putc(cgapalette, graphfile);
	putc(cgaborder, graphfile);
	fwrite((char *)&xcenter, sizeof(xcenter), 1, graphfile);
	fwrite((char *)&ycenter, sizeof(ycenter), 1, graphfile);
	fwrite((char *)&xsize, sizeof(xsize), 1, graphfile);
	fwrite((char *)&oldpercentage, sizeof(oldpercentage), 1, graphfile);
	fwrite((char *)&yfactor, sizeof(yfactor), 1, graphfile);
	fwrite((char *)&maxcount, sizeof(maxcount), 1, graphfile);
	fwrite((char *)&colorjump, sizeof(colorjump), 1, graphfile);
	fwrite((char *)&uniquecolors, sizeof(uniquecolors), 1, graphfile);
	fwrite((char *)ptable, sizeof(ptable), 1, graphfile);
	putc(method, graphfile);	/* method-code + extra-bytes */
	fwrite((char *)&i, sizeof(i), 1, graphfile);
	flags.critical = FALSE;
}


void prep_graph()
{
	int i;

	oldgraphmode = graphmode;	/* save graphmode asked for */
	if (flags.nodisp)
		printf("\nComputing now...\n");
	else {
		if (oldmode == TEXT80_EGAM) {
			if (!egamode) {
				flags.nodisp = TRUE;
				printf("\nNo CGA, display inhibited\n");
			}
			else
				for (i=0; i<MAX_MODES; i++)
					vtable[i] = 0x0F;
		}
		else if (graphmode >= 3 && !egamode) {
			if (graphmode == 3)
				graphmode = 1;
			else if (graphmode == 4)
				graphmode = 2;
			else if (graphmode >= 5) {
				graphmode = 2;
				flags.alternate = TRUE;
			}
		}
		else if (graphmode == 5 && egamode == 1 || desiredmode == 4) {
			graphmode = 4;
			flags.alternate = TRUE;
		}
		else if (graphmode == 6 && egamode != 4 || desiredmode == 5) {
			graphmode = 5;
			flags.alternate = TRUE;
		}
	}
	vwidth = 640;
	vheight = 200;
	rheight = vheight;
	if (graphmode == 1 || graphmode == 3)
		vwidth = 320;
	else if (graphmode < 5 && flags.alternate)
		vheight = 350;
	else if (graphmode < 6 && flags.alternate) {
		vheight = 480;
		rheight = 350;
	}
	else if (graphmode == 5) {
		vheight = 350;
		rheight = vheight;
	}
	else if (graphmode == 6) {
		vheight = 480;
		rheight = vheight;
	}
	oldpercentage = percentage;
	percentage = sqrt(percentage/100.0);
	hsize = (int)(vwidth * percentage);
	vsize = (int)(vheight * percentage);
	rsize = (int)(rheight * percentage);
	hoffset = (vwidth - hsize)/2;
	voffset = (rheight - rsize)/2;

	if (!colorjump)
		colorjump++;
	if (egasize == 1)	/* 64kb EGA has 3-color(+bkgd) limit */
		utable[4] = 4;
	if (uniquecolors > utable[graphmode-1]-1)
		uniquecolors = utable[graphmode-1]-1;
}


unsigned get_count()
{
	register unsigned c1, c2;

	if (!graphfile || flags.create)
		return(0);
	if (duptotal == 0) {
		/* if (!fread((char *)&count, sizeof(count), 1, graphfile)) { */
		if (!feof(graphfile))
			c1 = getc(graphfile);
		if (!feof(graphfile))
			c2 = getc(graphfile);
		else {
			flags.create = TRUE;
			clearerr(graphfile);
			if (flags.compact)
				fseek(graphfile, comppos, SEEK_SET);
			else
				fseek(graphfile, 0l, SEEK_CUR);
			return(dupvalue = 0);
		}
		if (method == OLD_METHOD)
			return(c1 + (c2 << 8));
		else {		/* assume method must be compact */
			duptotal = --c1;
			if (c2 != 0xff)
				return(dupvalue = c2);
			else
				return(dupvalue = maxcount);
		}
	}
	else {
		duptotal--;
		return(dupvalue);
	}
}


void put_count(count)
unsigned count;
{
	long l;
	unsigned c;

	if (graphfile)
		if (flags.create)
			if (method == OLD_METHOD)
				fwrite((char *)&count, sizeof(count), 1, graphfile);
			else {		/* assume method must be compact */
				if (dupvalue == 0)
					dupvalue = count;
				if (dupvalue != count || duptotal == 0xff) {
					if (dupvalue >= maxcount && maxcount >= 0xff)
						c = 0xff;
					else
						c = ((--dupvalue) % (0xfe) + 1);
					c = (c << 8) + duptotal;
					fwrite((char *)&c, sizeof(c), 1, graphfile);
					dupvalue = count;
					duptotal = 0;
				}
				duptotal++;
			}
		else if (flags.compact) {
			if (compvalue == 0)
				compvalue = count;
			if (compvalue != count || comptotal == 0xff) {
				if (compvalue >= maxcount && maxcount >= 0xff)
					c = 0xff;
				else
					c = ((--compvalue) % (0xfe) + 1);
				c = (c << 8) + comptotal;
				l = ftell(graphfile);
				fseek(graphfile, comppos, SEEK_SET);
				fwrite((char *)&c, sizeof(c), 1, graphfile);
				comppos += sizeof(c);
				fseek(graphfile, l, SEEK_SET);
				compvalue = count;
				comptotal = 0;
			}
			comptotal++;
		}
}


void do_graph()
{
	unsigned yi, c;
	register unsigned xi, count;
	double x, y, xcorner, ycorner;
	double step, stepinc;
	double a, b, ta, tb, m;

	#ifdef	PROTECT
	struct PhysBufData vpb;

	debug();
	vpb.buf_start = (Dword)Videoaddr;
	vpb.buf_length = 65536l;
	VIOGETPHYSBUF (&vpb, 0);
	Videoaddr = (Byte far *)((long)vpb.selectors[0] * 10000l);
	#endif

	xgap = xsize / hsize;
	ygap = (ysize = xsize * yfactor) / vsize;
	xcorner = xcenter - xsize/2.0;
	ycorner = ycenter + ysize/2.0;
	step = stepinc = vsize / 79.0;
	y = ycorner;
	for (yi = 1;  yi <= vsize;  yi++) {
		#ifdef	FASTX
		x = xcorner;
		#endif
		for (xi = 1;  xi <= hsize;  xi++) {
			count = get_count();
			if (!count) {	/* where 95% of the time goes... */
				#ifndef	FASTX
				x = xcorner + (xi-1)*xgap;
				#endif
				if ((xi & 0x0f) == 0)
					if (kbhit())
						;
				c = xi;	/* save register value */
				xi = maxcount;
				a = b = ta = tb = m = zero;
				while (count++ < xi && m < 4.0) {
					b = 2*a*b + y;
					a = ta-tb + x;
					m = (ta = a*a) + (tb = b*b);
				}
				xi = c;	/* restore register variable */
				count--;
			}		/* therefore, optimize properly... */
			else if ((xi & 0x7f) == 0)
				if (kbhit())
					;
			#ifdef	FASTX
			x += xgap;
			#endif
			if (!flags.nodisp)
				write_point(xi, yi, count);
			put_count(count);
		}
		y -= ygap;
		if (flags.nodisp)
			while (yi >= (unsigned)step) {
				printf("*");
				step += stepinc;
			}
	}
	if (method != OLD_METHOD) {
		put_count(0xffff);	/* a way to flush dup data */
		dupvalue = 0;
		duptotal = 0;		/* clear the dup variables now */
	}
}


void write_point(xi, yi, count)
register unsigned xi;
unsigned yi;
int count;
{
	register Byte color, i;
	union REGS regs;
	static Byte far *addr;
	static int lastxi = -2, lastyi = 0;
	static Byte lastcolor, lastmask = 0;
	static Byte mask[] = {0x80, 0x40, 0x20, 0x10,
					0x08, 0x04, 0x02, 0x01};

	if (flags.alternate)
		if (graphmode < 5) {
			if ( !(yi & 0x01) )
				return;
			else
				yi -= yi/2;
		}
		else {
			if ( !(yi & 0x03) )
				return;
			else {
				yi -= yi/4;
				if (yi > rsize)
					return;
			}
		}
	if (count >= maxcount)
		color = 0;
	else {
		if (colorjump > 1)
			count = (--count)/colorjump + 1;
		color = (Byte)((--count)%uniquecolors + 1);
		if (graphmode == 5 && egasize == 1)
			if (color >= 2)		/* for 64kb ega mode... */
				color += 2;	/* palette mapping differs */
	}
	yi = --yi+voffset;
	xi = --xi+hoffset;
	    /* for ega modes, blast directly to ram */
	#ifndef	PROTECT
	if (graphmode == 5 && egasize > 1 || graphmode == 6) {
	#endif
	    /* recompute byte address if pixel not sequential */
		if (xi != ++lastxi || yi != lastyi)
		    if (xi != 0 || yi != ++lastyi)
			addr = Videoaddr + (yi*80) + xi/8;
	    /* if a change in color has occurred, flush old color */
		if (color != lastcolor && (lastmask || flags.dirty)) {
			outb2(GRC_ADDR, 8, lastmask);
			if (flags.dirty) {
				outb2(SEQ_ADDR, 2, 0x0f);
				i = *addr;
				*addr = 0;
			}
			outb2(SEQ_ADDR, 2, lastcolor);
			lastcolor = *addr;
			*addr = 0xFF;	/* set bits in enabled planes */
			lastmask = 0;	/* all bits flushed */
		}
	    /* now record the current color and bit position */
		if (lastcolor = color)
			lastmask |= mask[xi & 0x07];
	    /* if last pixel this byte, or last pixel this line, flush */
		if ((xi & 0x07) == 0x07 || xi == hsize+hoffset-1) {
			outb2(GRC_ADDR, 8, lastmask);
			if (flags.dirty) {
				outb2(SEQ_ADDR, 2, 0x0f);
				i = *addr;
				*addr = 0;
			}
			outb2(SEQ_ADDR, 2, color);
			color = *addr;	/* latch all unmasked bits */
			*addr = 0xFF;	/* set bits in enabled planes */
			lastmask = 0;	/* all bits flushed */
			addr++;		/* adjust address every 8 pixels */
		}
	    /* record current coordinates to verify next pixel sequential */
		lastxi = xi;
		lastyi = yi;
	#ifndef	PROTECT
	}
	else {			/* use bios function otherwise */
		regs.h.al = color;	/* SORRY GUYS! */
		regs.h.ah = 0x0C;	/* write-dot function # */
		regs.h.bh = 0;		/* page # */
		regs.x.cx = xi;		/* column */
		regs.x.dx = yi;		/* and row, both relative to 0 */
		int86(0x10, &regs, &regs);
	}
	#endif
}


Byte read_dot(xi, yi)
unsigned xi, yi;
{
	union REGS regs;

	#ifndef	PROTECT
	regs.h.ah = 0x0D;	/* read-dot function # */
	regs.h.bh = 0;		/* page # */
	regs.x.cx = --xi+hoffset;	/* column */
	regs.x.dx = --yi+voffset;	/* and row, both relative to 0 */
	int86(0x10, &regs, &regs);
	#endif
	return(regs.h.al);	/* return color */
}


void write_dot(xi, yi, color)
register unsigned xi, yi;
Byte color;
{
	union REGS regs;

	#ifndef	PROTECT
	regs.h.ah = 0x0C;	/* write-dot function # */
	regs.h.al = color;
	regs.h.bh = 0;		/* page # */
	regs.x.cx = --xi+hoffset;	/* column */
	regs.x.dx = --yi+voffset;	/* and row, both relative to 0 */
	int86(0x10, &regs, &regs);
	return;
	#endif
}


void get_switches(count, tbladr)
int	count;
char	**tbladr;
{
	int total;

	for (total = count; count > 0; count--,tbladr++) {
		if (**tbladr == '-' || **tbladr == '/') {
			(*tbladr)++;		/* past switch char */
			switch (tolower(*(*tbladr)++)) {
			case 'h':		/* past 1st letter now */
			case '?':
				flags.help = TRUE;
				help();
				if (total > 1) {
					putchar('\n');
					break;
				}
				else
					exit(0);
			case 'l':
				do_title();
				fprintf(stderr,
					"Load option not supported yet\n\n");
				flags.error = TRUE;
				break;
			case 'e':
				flags.ega = TRUE;
				if (tolower(**tbladr) == 'm')
					egamode = 2;
				else
					egamode = 1;
				break;
			case 'b':
				flags.batch = TRUE;
				break;
			case 'd':
				flags.debug = TRUE;
				break;
			case 'n':
				flags.nodisp = TRUE;
				break;
			case 't':
				flags.time = TRUE;
				break;
			case 'k':
				colorlist = *tbladr;
				break;
			case 'j':
				colorjump = atoi(*tbladr);
				break;
			case 'c':
				flags.create = TRUE;
				if (tolower(**tbladr) == 'u')
					flags.ucreate = TRUE;
				break;
			case 's':
				flags.std = TRUE;
				break;
			case 'v':
				flags.pause = TRUE;
				break;
			case 'i':
				strcpy(imagename, *tbladr);
				break;
			case 'x':
				flags.x = TRUE;
				xcenter = atof(*tbladr);
				break;
			case 'y':
				flags.y = TRUE;
				ycenter = atof(*tbladr);
				break;
			case 'w':
				flags.size = TRUE;
				xsize = atof(*tbladr);
				break;
			case 'p':
				flags.percent = TRUE;
				percentage = atof(*tbladr);
				break;
			case 'r':
				flags.ratio = TRUE;
				yfactor = atof(*tbladr);
				break;
			case 'g':
				flags.mode = TRUE;
				graphmode = atoi(*tbladr);
				break;
			case 'm':
				flags.count = TRUE;
				maxcount = atoi(*tbladr);
				break;
			case 'f':
				flags.method = TRUE;
				method = (Byte)atoi(*tbladr);
				break;
			default:
				do_title();
				fprintf(stderr,
					"Unknown option: %c\n", *(*tbladr-1));
				flags.error = TRUE;
				break;
			}
		}
		else {
			if (!graphname[0])
				strcpy(graphname, *tbladr);
			else {
				do_title();
				fprintf(stderr,
					"Argument ignored: %s\n", *tbladr);
				flags.error = TRUE;
			}
		}
	}
	if (flags.error || flags.help && flags.batch)
		press_key();
}


void help()
{
	do_title();
	puts("\
Usage:    mbrot [graph-file] [options...]\n\n\
Options:  -h	list usage and options\n\
	  -b	select batch-mode operation\n\
	  -n	inhibit display during computation\n\
	  -k...	defines colors (ie, B1b1g1c1r1m1o1w1)\n\
	  -j#	defines color granularity\n\
	  -c	create graph-file (default is restore)\n\
	  -cu	create graph-file unconditionally\n");
	puts("\
	  -x#.#	set x(real) co-ordinate of center\n\
	  -y#.#	set y(imaginary) co-ordinate of center\n\
	  -w#.#	set width(real) of graph\n\
	  -p#	set percentage of screen to be used\n\
	  -r#.#	set vertical/horizontal ratio\n\
	  -g#	select graphics mode #\n\
	  -m#	specify maximum iterations per pixel\n");
#ifdef	COMPLETE
	puts("\
	  -ifn	add graph to image-library-file fn\n\
	  -v	pause after each frame of image-library\n\
	  -s	specify standard algorithm (non-recursive)\n");
#endif
}


void clr_kbd()
{
	while (kbhit())
		getch();
}


void press_key()
{
	FILE *f;

	if (flags.error)
		f = stderr;
	else
		f = stdout;
	fprintf(f, "\nPress any key to continue...");
	clr_kbd();
	getch();
	putchar('\n');
	flags.error = FALSE;
}


char inp_char()
{
	char c;

	c = (char)tolower(getche());
	putchar('\n');
	return(c);
}


int inp_line(fmt, arg1)
char	*fmt;
double	*arg1;
{
	char	line[132];

	if (!gets(line))
		exit(0);
	return(sscanf(line, fmt, arg1));
}


void setvideo(m)
register Byte m;
{
	if (m >= TOTAL_MODES)
		m = TOTAL_MODES - 1;
	disable_video();
	setega_extregs(m);
	setega_seqregs(m);
	setega_crtregs(m);
	setega_grcregs(m);
	setega_attregs(m);
	enable_video();
}


void disable_video()
{
	outb(ATT_CONT, 0x00);
}


void enable_video()
{
	outb(ATT_CONT, 0x20);
}


void setega_extregs(m)
register Byte m;
{
	static Byte miscs[] = {0xA7, 0xA7, 0xA7};
	static Byte feats[] = {0x00, 0x00, 0x00};

	outb(MISC_OUT, miscs[m]);
	outb(Feat_reg, feats[m]);
}


void setega_seqregs(m)
register Byte m;
{
	register int i;
	static Word resets[]   = {0x0300, 0x0300, 0x0300};
	static Word clkmodes[] = {0x0101, 0x0501, 0x0101};
	static Word mapmasks[] = {0x0302, 0x0F02, 0x0F02};
	static Word charmaps[] = {0x0003, 0x0003, 0x0003};
	static Word memmodes[] = {0x0304, 0x0004, 0x0604};
	static Word *regs[] = {resets, clkmodes,
				mapmasks, charmaps, memmodes};

	for (i=0; i<sizeof(regs)/sizeof(Word *); i++)
		outw(SEQ_ADDR, (regs[i])[m]);
}


void setega_crtregs(m)
register Byte m;
{
	register int i;
	static Word htotals[]  = {0x5B00, 0x5B00, 0x5B00};
	static Word hdspends[] = {0x4F01, 0x4F01, 0x4F01};
	static Word hsblanks[] = {0x5302, 0x5302, 0x5302};
	static Word heblanks[] = {0x3703, 0x1703, 0x3703};
	static Word hsretrcs[] = {0x5104, 0x5004, 0x5204};
	static Word heretrcs[] = {0x5B05, 0xBA05, 0x0005};
	static Word vtotals[]  = {0x6C06, 0x6C06, 0x6C06};
	static Word crtovfls[] = {0x1F07, 0x1F07, 0x1F07};
	static Word presets[]  = {0x0008, 0x0008, 0x0008};
	static Word maxscans[] = {0x0D09, 0x0009, 0x0009};
	static Word cstarts[]  = {0x0B0A, 0x000A, 0x000A};
	static Word curends[]  = {0x0C0B, 0x000B, 0x000B};
	static Word hiaddrs[]  = {0x000C, 0x000C, 0x000C};
	static Word loaddrs[]  = {0x000D, 0x000D, 0x000D};
	static Word chiaddrs[] = {0x000E, 0x000E, 0x000E};
	static Word cloaddrs[] = {0x000F, 0x000F, 0x000F};
	static Word vsretrcs[] = {0x5E10, 0x5E10, 0x5E10};
	static Word veretrcs[] = {0x2B11, 0x2B11, 0x2B11};
	static Word vdspends[] = {0x5D12, 0x5D12, 0x5D12};
	static Word offsets[]  = {0x2813, 0x1413, 0x2813};
	static Word undlocs[]  = {0x0F14, 0x0F14, 0x0F14};
	static Word vsblanks[] = {0x5E15, 0x5F15, 0x5F15};
	static Word veblanks[] = {0x0A16, 0x0A16, 0x0A16};
	static Word modctrls[] = {0xA317, 0x8B17, 0xE317};
	static Word lincomps[] = {0xFF18, 0xFF18, 0xFF18};
	static Word *regs[] = {htotals, hdspends, hsblanks, heblanks,
				hsretrcs, heretrcs, vtotals, crtovfls,
				presets, maxscans, cstarts, curends,
				hiaddrs, loaddrs, chiaddrs, cloaddrs,
				vsretrcs, veretrcs, vdspends, offsets,
				undlocs, vsblanks, veblanks, modctrls,
				lincomps};

	for (i=0; i<sizeof(regs)/sizeof(Word *); i++)
		outw(Crt_addr, (regs[i])[m]);
}


void setega_grcregs(m)
register Byte m;
{
	register int i;
	static Word moderegs[] = {0x1005, 0x1005, 0x0005};
	static Word miscs[]    = {0x0E06, 0x0706, 0x0506};
	static Word nocares[]  = {0x0007, 0x0F07, 0x0F07};
	static Word bitmasks[] = {0xFF08, 0xFF08, 0xFF08};
	static Word *regs[] = {moderegs, miscs, nocares, bitmasks};

	outb(GR1_POS, 0);
	outb(GR2_POS, 1);
	for (i=0; i<=4; i++)
		outw(GRC_ADDR, i);
	for (i=0; i<sizeof(regs)/sizeof(Word *); i++)
		outw(GRC_ADDR, (regs[i])[m]);
}


void setega_attregs(m)
register Byte m;
{
	register int i;
	static Byte att0s[]    = {0x00, 0x00, 0x00};
	static Byte att1s[]    = {0x01, 0x01, 0x01};
	static Byte att2s[]    = {0x02, 0x00, 0x02};
	static Byte att3s[]    = {0x03, 0x00, 0x03};
	static Byte att4s[]    = {0x04, 0x04, 0x04};
	static Byte att5s[]    = {0x05, 0x07, 0x05};
	static Byte att6s[]    = {0x14, 0x00, 0x06};
	static Byte att7s[]    = {0x07, 0x00, 0x07};
	static Byte att8s[]    = {0x38, 0x00, 0x38};
	static Byte att9s[]    = {0x39, 0x01, 0x39};
	static Byte attas[]    = {0x3A, 0x00, 0x3A};
	static Byte attbs[]    = {0x3B, 0x00, 0x3B};
	static Byte attcs[]    = {0x3C, 0x04, 0x3C};
	static Byte attds[]    = {0x3D, 0x07, 0x3D};
	static Byte attes[]    = {0x3E, 0x00, 0x3E};
	static Byte attfs[]    = {0x3F, 0x00, 0x3F};
	static Byte modctrls[] = {0x08, 0x0B, 0x01};
	static Byte overscns[] = {0x00, 0x00, 0x00};
	static Byte planes[]   = {0x0F, 0x05, 0x0F};
	static Byte hpans[]    = {0x00, 0x00, 0x00};
	static Byte *regs[] = {att0s, att1s, att2s, att3s,
				att4s, att5s, att6s, att7s,
				att8s, att9s, attas, attbs,
				attcs, attds, attes, attfs,
				modctrls, overscns, planes, hpans};

	for (i=0; i<sizeof(regs)/sizeof(Word *); i++)
		outb2(ATT_CONT, (Byte)i, (regs[i])[m]);
}

